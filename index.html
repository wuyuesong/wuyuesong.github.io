<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/%5Cimages/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/%5Cimages/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/%5Cimages/favicon-16x16-next.png">
  <link rel="mask-icon" href="/%5Cimages/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"101.35.161.126","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="wys的个人博客">
<meta property="og:url" content="https://101.35.161.126/index.html">
<meta property="og:site_name" content="wys的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://101.35.161.126/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>wys的个人博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?176038d5e76ea511f3c7ecd6a3813b97";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wys的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你有很多事放不下？做人要潇洒一点~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/09/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_11/" class="post-title-link" itemprop="url">数据库————恢复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-05 10:27:27" itemprop="dateCreated datePublished" datetime="2022-09-05T10:27:27+08:00">2022-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:56:44" itemprop="dateModified" datetime="2022-09-15T19:56:44+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="恢复">恢复</h1>
<h2 id="动机">1. 动机</h2>
<p>在前面的模块中，我们讨论了事务的ACID属性。在本文中，我们将讨论如何使数据库具有故障恢复能力。我们将在本注释中学习如何实施的两个ACID属性是：</p>
<ol type="1">
<li><p>持久性：如果事务完成（提交），我们将永远不会丢失事务的结果。</p></li>
<li><p>原子性：事务中的所有或所有操作都将保持。这意味着我们永远不会让数据库处于中间状态。例如，在CalCentral中交换类。有两个操作：删除旧类和添加新类。如果数据库在添加新类之前崩溃，您实际上不想从旧类中删除。</p></li>
</ol>
<h2 id="强制非强制">2 .强制非强制</h2>
<p>如果我们使用强制策略，持久性可以是一个非常简单的属性。强制策略声明，当事务完成时，在事务提交之前，强制将所有修改的数据页发送到磁盘。这将确保持久性，因为磁盘是persistent1；换句话说，一旦页面进入磁盘，它将被永久保存。这种方法的缺点是性能。我们最终做了很多不必要的写入。我们更喜欢的策略是不强制，即只在页面需要从缓冲池中退出时才写回磁盘。虽然这有助于减少不必要的写入，但会使持久性复杂化，因为如果在事务提交后数据库崩溃，某些页面可能尚未写入磁盘，因此会从内存中丢失，因为内存是易失性的。为了解决此问题，我们将在恢复期间重新执行某些操作</p>
<h2 id="stealno-steal">3 Steal/No-Steal</h2>
<p>类似地，使用No-Steal策略很容易确保原子性。No-Steal策略规定，在事务提交之前，不能从内存中逐出页面（从而写入磁盘）。这确保了我们不会让数据库处于中间状态，因为如果事务没有完成，那么它的任何更改实际上都不会写入磁盘并保存。这个政策的问题在于它限制了我们如何使用内存。我们必须将每个修改过的页面保留在内存中，直到事务完成。我们更希望有一个Steal策略，允许在事务完成之前将修改过的页面写入磁盘。这将使执行原子性变得复杂，但我们将通过在恢复期间撤消错误操作来解决此问题。</p>
<h2 id="steal-no-force">4 Steal, No-Force</h2>
<p>回顾一下，我们选择使用两种策略（steal，no-force），这使得很难保证原子性和持久性，但可以获得最佳性能。本说明的其余部分将介绍如何确保原子性和耐用性，同时使用steal、No-Force</p>
<h2 id="提前写入日志">5.提前写入日志</h2>
<p>为了解决这些复杂问题，我们将使用日志记录。日志是描述数据库所做操作的一系列日志记录。</p>
<h3 id="更新日志记录">5.1更新日志记录</h3>
<p>每个写操作（SQL插入/删除/更新）都将获得自己的日志更新记录。</p>
<p>更新日志记录如下所示：</p>
<figure>
<img src="/2022/09/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_11/image-20220913204008887.png" alt="image-20220913204008887"><figcaption aria-hidden="true">image-20220913204008887</figcaption>
</figure>
<p>这些字段包括：</p>
<p>•XID：事务ID-告诉我们哪个事务执行了此操作</p>
<p>•页面ID：已修改的页面</p>
<p>•偏移量：页面上数据开始变化的位置（通常以字节为单位）</p>
<p>•长度：更改了多少数据（通常以字节为单位）</p>
<p>•旧数据：原始数据（用于撤销操作）</p>
<p>•新数据：数据更新为什么（用于重做操作）</p>
<h2 id="其他日志记录">5.2其他日志记录</h2>
<p>我们将在日志中使用其他一些记录类型。随着对这些字段的需求变得明显，我们将在整个注释中将这些字段添加到这些日志记录中。</p>
<p>•提交：表示事务正在启动提交过程</p>
<p>•中止：表示事务正在启动中止过程</p>
<p>•结束：表示事务已完成（通常意味着它已完成提交或中止）</p>
<h2 id="wal要求">5.3 WAL要求</h2>
<p>和常规数据页一样，日志页需要在内存中操作，但需要写入磁盘以永久存储。提前写入日志（WAL）对何时必须将日志写入磁盘提出了要求。这两条规则如下：</p>
<ol type="1">
<li><p>日志记录必须在相应的数据页写入磁盘之前写入磁盘。这就是我们将如何实现原子性。对此的直觉是，如果先写入数据页，然后数据库崩溃，我们就无法撤消操作，因为我们不知道发生了什么操作！</p></li>
<li><p>事务提交时，所有日志记录都必须写入磁盘。这就是我们将如何实现持久性。直觉是，我们需要持续跟踪提交的事务执行了哪些操作。否则，我们将不知道需要重做哪些操作。通过将所有日志写入磁盘，我们可以准确地知道在修改后的数据页写入磁盘之前，如果数据库崩溃，我们需要重做哪些操作！</p></li>
</ol>
<h2 id="wal实施">6 WAL实施</h2>
<p>为了实现预写日志记录，我们将在日志记录中添加一个名为LSN的字段，它代表日志序列号。LSN是一个唯一的递增数，有助于表示操作顺序（如果您看到LSN=20的日志记录，则该操作发生在LSN=10的记录之后）。在这个类中，LSN将每次增加10，但这只是一个约定。我们还将在每个日志记录中添加一个prevLSN字段，该字段存储来自同一事务的最后一个操作（这将有助于撤消事务）。数据库还将跟踪存储在RAM中的flushedLSN。flushedLSN跟踪已刷新到磁盘的最后一条日志记录的LSN。刷新页面时，表示页面已写入磁盘；这通常还意味着我们将页面从内存中逐出，因为我们不再需要它了。flushedLSN告诉我们，之前的任何日志记录都不应写入磁盘，因为它们已经存在。日志页通常附加到磁盘上的上一个日志页，因此多次写入相同的日志意味着我们存储了重复数据，这也会扰乱日志的连续性。我们还将向每个数据页添加一段元数据，称为pageLSN。页面LSN存储上次修改页面的操作的LSN。我们将使用它来帮助告诉我们哪些操作实际进入磁盘，哪些操作必须重做。</p>
<h2 id="不等式练习">7.不等式练习</h2>
<p>在允许将第一页刷新到磁盘之前，必须保持什么不等式？</p>
<p>​ pageLSNi ___ flushedLSN</p>
<p>答复:≤, 这来自WAL的第一条规则——在将数据页刷新到磁盘之前，必须刷新相应的日志记录。仅当上次修改数据页的操作的LSN小于或等于flushedLSN时，数据页才会刷新到磁盘。换句话说，在将页面i刷新到磁盘之前，必须将修改页面i的所有操作的日志记录刷新到磁盘。</p>
<h2 id="中止交易">8.中止交易</h2>
<p>在从崩溃中恢复之前，让我们先了解数据库如何中止正在进行的事务。我们可能希望由于死锁而中止事务，或者用户可能因为事务花费太长而决定中止。如果操作违反某些完整性约束，也可以中止事务，以保证ACID中的一致性。最后，由于系统崩溃，事务可能需要中止！我们需要确保，一旦中止过程完成，所有操作都不会保留到磁盘。</p>
<h3 id="中止和clr日志记录">8.1中止和CLR日志记录</h3>
<p>我们要做的第一件事是在日志中写入一条中止记录，表示我们正在启动进程。然后，我们将从该事务日志中的最后一个操作开始。我们将撤消事务中的每个操作，并为每个撤消的操作将CLR记录写入日志。CLR（补偿日志记录）是一种新类型的记录，表示我们正在撤消特定操作。它本质上与更新记录相同（它存储以前的状态和新状态），但它告诉我们，该写操作是由于中止而发生的。</p>
<h2 id="恢复数据结构">9 恢复数据结构</h2>
<p>我们将保留两个状态表，以使恢复过程更容易一些。第一个表称为事务表，它存储关于活动事务的信息。事务表有三个字段：</p>
<p>•XID：交易ID</p>
<p>•状态：运行、提交或中止</p>
<p>•lastLSN：此交易最近一次操作的LSN</p>
<p>交易表示例如下：</p>
<figure>
<img src="/2022/09/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_11/image-20220913205955915.png" alt="image-20220913205955915"><figcaption aria-hidden="true">image-20220913205955915</figcaption>
</figure>
<p>我们维护的另一个表称为脏页表（DPT）。DPT跟踪哪些页面是脏的（回想以前的许多模块，脏意味着页面已经在内存中修改，但尚未刷新到磁盘）。这些信息将非常有用，因为它将告诉我们哪些页面具有尚未进入磁盘的操作。DPT只有两列：</p>
<p>•页面ID</p>
<p>•recLSN：第一个弄脏页面的操作</p>
<p>DPT的示例如下：</p>
<figure>
<img src="/2022/09/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_11/image-20220913210112697.png" alt="image-20220913210112697"><figcaption aria-hidden="true">image-20220913210112697</figcaption>
</figure>
<p>需要注意的是，这两个表都存储在内存中；因此，当从崩溃中恢复时，必须使用日志重建表。我们将在本说明的后面讨论一种使这更容易的方法（检查点）。</p>
<h2 id="更多不等式问题">10更多不等式问题</h2>
<ol type="1">
<li>填写以下等式以强制执行WAL规则，即在事务T提交之前，必须将所有日志刷新到磁盘：</li>
</ol>
<p>​ flushedLSN ___ lastLSNT</p>
<p>回答：≥ 如果flushedLSN 大于事务的最后一次操作，则我们知道该事务的所有日志都在磁盘上。</p>
<ol start="2" type="1">
<li><p>对于DPT中的页面P，填写以下不等式，该不等式必须始终为真：</p>
<p>​ recLSNP ___ in memory pageLSNP</p></li>
</ol>
<p>回答:≤ 如果页面位于脏页表中，则该页面必须是脏的，因此上次更新一定没有将其更新到磁盘。recLSN是第一个弄脏页面的操作，因此它必须小于修改该页面的最后一个操作。</p>
<ol start="3" type="1">
<li></li>
</ol>
<p>​ recLSNp ____ 磁盘上的recLSNP页</p>
<p>答案：&gt;如果页面是脏的，则导致页面变脏的操作（recLSN）一定没有将其发送到磁盘，因此它一定是在将页面发送到磁盘的操作之后</p>
<p>那一页。</p>
<h2 id="撤消日志记录">11撤消日志记录</h2>
<p>我们已经介绍了数据库如何写入日志以及在正常运行时如何中止事务的大量背景信息。现在，让我们最终了解所有这些日志记录的原因——从失败中恢复。一种可能的恢复机制是撤消日志记录。请注意，撤销日志记录实际上并没有使用我们之前讨论过的提前写入日志记录（WAL）（我们稍后将回到这一点）。此外，它在缓冲池管理方面使用强制和窃取机制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/" class="post-title-link" itemprop="url">数据库————事务与并发 II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-30 10:27:27" itemprop="dateCreated datePublished" datetime="2022-08-30T10:27:27+08:00">2022-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:53:51" itemprop="dateModified" datetime="2022-09-15T19:53:51+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务与并发-ii">事务与并发 II</h1>
<h2 id="导言">1 导言</h2>
<p>在最后一个注释中，我们介绍了作为ACID性质之一的隔离概念。让我们在这里重新审视我们的定义：</p>
<ul>
<li>隔离：每个Xact的执行与其他执行隔离。实际上，DBMS将交错许多XACT的动作，而不是按顺序依次执行。DBMS将确保每个Xact的执行就像它自己运行一样。</li>
</ul>
<p>本说明将详细介绍DBMS如何能够在保证隔离的同时交错许多事务的操作。</p>
<h2 id="两阶段锁">2.两阶段锁</h2>
<p>什么是锁，为什么它们有用？锁基本上允许事务读取和写入数据。例如，如果事务T1正在从资源A读取数据，则需要确保没有其他事务同时修改资源A。因此，想要读取数据的事务将请求在适当资源上的共享（S）锁，而想要写入数据的事务则将请求在相应资源上的排他（X）锁。只有一个事务可以对资源持有独占锁，但许多事务可以对数据持有共享锁。两阶段锁定（2PL）是一种确保数据库使用冲突可串行化调度的方案。2PL的两个规则是：</p>
<ul>
<li><p>交易必须在读取前获得S（共享）锁，在写入前获得X（独占）锁。</p></li>
<li><p>在释放任何锁后，事务无法获取新锁——这是通过锁定实现可串行化的关键！</p></li>
</ul>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910085705898.png" alt="image-20220910085705898"><figcaption aria-hidden="true">image-20220910085705898</figcaption>
</figure>
<p>这样做的问题是它不能防止级联中止。例如</p>
<ul>
<li><p>T1更新资源A，然后释放对A的锁定。</p></li>
<li><p>T2从A读取。</p></li>
<li><p>T1中断。</p></li>
<li><p>在这种情况下，T2也必须中止，因为它读取了未提交的值A。</p></li>
</ul>
<p>为了解决这个问题，我们将使用严格的两相锁定。严格的2PL与2PL相同，只是当事务完成时所有锁一起释放。</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910090520577.png" alt="image-20220910090520577"><figcaption aria-hidden="true">image-20220910090520577</figcaption>
</figure>
<h2 id="锁管理">3 锁管理</h2>
<p>现在我们知道了锁的用途和类型。我们将了解锁管理器1如何管理这些锁和解锁（或获取和释放）请求，以及它如何决定何时授予锁。</p>
<p>LM维护一个哈希表，该哈希表以被锁定资源的名称为键。每个条目包含一个授权集（一组授权锁/持有每个资源锁的事务）、锁类型（S或X或我们尚未引入的类型）和等待队列（由于与已授权的锁冲突而无法满足的锁请求队列）。见下图：</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910090711070.png" alt="image-20220910090711070"><figcaption aria-hidden="true">image-20220910090711070</figcaption>
</figure>
<p>当锁请求到达时，锁管理器将检查授权集中或等待队列中的任何Xact是否需要冲突锁。如果是，请求者将被放入等待队列。如果不是，则请求者被授予锁，并被放入授权集。</p>
<p>此外，Xacts可以请求锁升级：这是具有共享锁的Xact可以请求升级到独占锁的情况。锁管理器将在队列的前面添加此升级请求。</p>
<p>下面是一些如何处理队列的伪代码；请注意，它并没有明确说明在促销等情况下应该做什么，但这是一个很好的概述。</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910090938990.png" alt="image-20220910090938990"><figcaption aria-hidden="true">image-20220910090938990</figcaption>
</figure>
<p>请注意，此实现不允许队列跳过。当请求在队列跳过实现下到达时，我们首先检查是否可以根据资源上持有的锁授予锁；如果无法授予锁，则将其放在队列的后面。释放锁并处理队列时，授予与当前持有的锁兼容的任何锁</p>
<p>有关队列跳过和伪代码的示例，请参阅附录。然而，它依赖于您对多粒度锁定的理解，因此请确保先阅读第7节以理解示例。</p>
<h2 id="死锁">4 死锁</h2>
<p>我们现在有了一个锁管理器，如果存在冲突锁，它将请求者放入等待队列。但是，如果T1和T2都持有资源上的S锁，并且都尝试升级到X，会发生什么？T1将等待T2释放S锁，以便它可以获得X锁，而T2将等待T1释放S，以便它能够获得X锁。此时，两个事务都无法获得X锁，因为它们正在等待对方！这称为死锁，一个XACT循环等待锁被彼此释放。</p>
<h2 id="避免">4.1避免</h2>
<p>解决死锁的一种方法是尽量避免陷入死锁。我们将根据年龄分配Xact的优先级：现在-开始时间。如果<span class="math inline">\(T_i\)</span>想获得<span class="math inline">\(T_j\)</span>持有的锁，我们有两种选择：</p>
<ul>
<li>Wait-Die: 如果<span class="math inline">\(T_i\)</span>具有更高的优先级，则<span class="math inline">\(T_i\)</span>等待<span class="math inline">\(T_j\)</span>；否则<span class="math inline">\(T_i\)</span>将中止</li>
<li>Wound-Wait: 如果<span class="math inline">\(T_i\)</span>具有更高的优先级，<span class="math inline">\(T_j\)</span>中止；否则，<span class="math inline">\(T_i\)</span>会等待</li>
</ul>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910092234448.png" alt="image-20220910092234448"><figcaption aria-hidden="true">image-20220910092234448</figcaption>
</figure>
<h2 id="检测">4.2检测</h2>
<p>虽然我们在上面的方法中避免了死锁，但我们最终中止了许多事务！相反，我们可以尝试检测死锁，如果发现死锁，则中止死锁中的一个事务，以便其他事务可以继续。</p>
<p>我们将通过创建和维护“等待”图来检测死锁。如果满足以下条件，该图对于每个Xact将有一个节点，并且从<span class="math inline">\(T_i\)</span>到<span class="math inline">\(T_j\)</span>有一条边，如果：</p>
<ul>
<li><span class="math inline">\(T_j\)</span> 持有资源X的锁</li>
<li><span class="math inline">\(T_i\)</span> 尝试获取资源X上的锁，但是<span class="math inline">\(T_i\)</span> 在拿到期望的锁之前， <span class="math inline">\(T_j\)</span> 必须释放在资源X上的锁</li>
</ul>
<p>例如，下图具有从T1到T2的边，因为T2获取B上的锁后，T1尝试获取B上冲突的锁。因此，T1等待T2。</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910093625691.png" alt="image-20220910093625691"><figcaption aria-hidden="true">image-20220910093625691</figcaption>
</figure>
<p>如果一个事务<span class="math inline">\(T_i\)</span>正在等待另一个事务<span class="math inline">\(T_j\)</span>（即，从<span class="math inline">\(T_i\)</span>到<span class="math inline">\(T_j\)</span>有一条边），则<span class="math inline">\(T_i\)</span>不能获取任何新锁。因此，事务 <span class="math inline">\(T_k\)</span> 将不会等待资源X上的 <span class="math inline">\(T_i\)</span>，除非 <span class="math inline">\(T_i\)</span> 在开始等待 <span class="math inline">\(T_j\)</span> 之前获得了X上的冲突锁。</p>
<p>考虑下面的示例，同时请记住，调度中只显示锁获取，而不是锁释放。</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910094202055.png" alt="image-20220910094202055"><figcaption aria-hidden="true">image-20220910094202055</figcaption>
</figure>
<p>当<span class="math inline">\(T_2\)</span> 请求一个在资源A上冲突的S锁的时候，从<span class="math inline">\(T_2\)</span> 到 <span class="math inline">\(T_1\)</span> 将连一条边，因为 <span class="math inline">\(T_1\)</span> 持有 X 锁 。当 <span class="math inline">\(T_2\)</span> 等待 <span class="math inline">\(T_1\)</span> 结束资源A的使用的时候，<span class="math inline">\(T_2\)</span> 中的任何操作都不能执行，直到他被移除等待队列。这也是为什么 <span class="math inline">\(T_3\)</span> 在请求B上的S锁时，不用等待 <span class="math inline">\(T_2\)</span> ，因为<span class="math inline">\(T_2\)</span> 在等待<span class="math inline">\(T_1\)</span>的过程中从来没有获取到B上的X锁。 同样的，当 <span class="math inline">\(T_3\)</span> 想要获得A上的X锁的时候 ，只用等待 <span class="math inline">\(T_1\)</span> 因为在这个时候只有<span class="math inline">\(T_1\)</span> 在资源 A 上和<span class="math inline">\(T_3\)</span> 有互斥的锁。注意在这个时候<span class="math inline">\(T_2\)</span> 和 <span class="math inline">\(T_3\)</span> 在资源 A 的等待队列里。</p>
<p>我们将定期检查图中表示死锁的循环。如果发现一个循环，我们将在循环中“杀死”一个Xact并中止它以打破循环。</p>
<p>重要提示：“等待”图用于周期检测，与我们之前讨论的冲突依赖关系图（在前一个note中）不同，后者用于确定事务调度是否可序列化。</p>
<h2 id="锁粒度">5 锁粒度</h2>
<p>现在我们已经理解了锁定的概念，我们想知道实际锁定什么。是否要锁定包含要写入的数据的元组？还是页面？还是桌子？或者甚至是整个数据库，以便在我们处理数据库时，没有事务可以写入该数据库？正如你所猜测的，我们所做的决定将根据我们所处的情况有很大的不同。</p>
<p>让我们将数据库系统视为以下树：</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910192857931.png" alt="image-20220910192857931"><figcaption aria-hidden="true">image-20220910192857931</figcaption>
</figure>
<p>顶层是数据库。下一级是表，后面是表的页面。最后，表本身的记录是树中的最低级别。</p>
<p>请记住，当我们在一个节点上放置一个锁时，我们也会隐式地锁定它的所有子节点（直观地说，可以这样想：如果您在一个页面上放置了一个锁，那么您就隐式地在所有记录上放置了锁，并阻止其他任何人修改它）。因此，您可以看到我们希望如何能够向数据库系统指定我们真正希望将锁放在哪个级别；它允许我们在树的不同级别上放置锁。</p>
<p>我们将有以下新的锁定模式：</p>
<ul>
<li><p>IS：更精细的粒度的S意向锁。</p></li>
<li><p>IX：更精细的粒度d额X意向锁。注意：两个事务可以在同一资源上放置一个IX锁——它们在这一点上没有直接冲突，因为它们可以在两个不同的子级上放置X锁！因此，我们将其留给数据库管理器，以确保它们不会在同一节点上放置X锁，同时允许在同一资源上使用两个IX锁。</p></li>
<li><p>SIX：等价于同时施加了S锁和IX锁。如果我们希望防止任何其他事务修改较低级别的资源，但希望允许它们读取较低级别，则这很有用。在这里，我们说在这个级别上，我要求共享锁；现在，任何其他事务都不能对该子树中的任何内容声明独占锁（但是，它可能会对未被该事务修改的内容声明共享锁，即我们不会将X锁置于其上的内容。这留给数据库系统处理）。</p></li>
</ul>
<p>有趣的是，请注意，任何其他事务都不能在具有SIX锁的节点上声明S锁，因为这将在整个树上放置两个事务的共享锁，这将阻止我们修改该子树中的任何内容。唯一与SIX锁兼容的锁是IS。</p>
<p>以下是兼容性矩阵：；将轴解释为事务T1和事务T2。例如，考虑条目X，S–这意味着T1不可能在资源上持有X锁，而T2在同一资源上持有S锁。NL代表无锁。</p>
<figure>
<img src="/2022/08/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_10/image-20220910220056954.png" alt="image-20220910220056954"><figcaption aria-hidden="true">image-20220910220056954</figcaption>
</figure>
<h3 id="多粒度锁定协议">5.1 多粒度锁定协议</h3>
<ol type="1">
<li><p>每个Xact从层次结构的根开始。</p></li>
<li><p>要在节点上获得S或IS锁，必须在父节点上保持IS或IX。</p></li>
<li><p>要在节点上获得X或IX，必须在父节点上保持IX或SIX。</p></li>
<li><p>必须以自下而上的顺序释放锁。</p></li>
<li><p>还实施了2阶段和锁兼容性矩阵规则</p></li>
<li><p>协议是正确的，因为它相当于在层次结构的叶级直接设置锁。</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/08/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_9/" class="post-title-link" itemprop="url">数据库————事务和并发I</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-25 10:27:27" itemprop="dateCreated datePublished" datetime="2022-08-25T10:27:27+08:00">2022-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:56:23" itemprop="dateModified" datetime="2022-09-15T19:56:23+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务和并发i">事务和并发I</h1>
<h2 id="导言">1 导言</h2>
<p>在现实中，我们通常不会一次只有一个人访问数据库。许多用户可以一次向数据库发出请求，这可能会导致并发问题。当一个用户写入，然后另一个用户从同一资源读取时会发生什么？如果两个用户都试图写入同一资源，会怎么样？如果不小心，当几个用户同时使用数据库时，我们可能会遇到几个问题：</p>
<ul>
<li>读取不一致：用户仅读取更新内容的一部分。</li>
</ul>
<p>​ –用户1更新表1，然后更新表2。</p>
<p>​ –用户2读取表2（用户1尚未更新），然后读取表1（用户1已更新），因此它以中间状态读取数据库</p>
<ul>
<li>丢失更新：两个用户试图更新同一记录，因此其中一个更新丢失。对于</li>
</ul>
<p>​ 例子：</p>
<p>​ –用户1将玩具的价格更新为价格*2。</p>
<p>​ –用户2将玩具的价格更新为价格+5，取消了用户1的更新</p>
<ul>
<li>脏读：一个用户读取从未提交的更新。</li>
</ul>
<p>​ –用户1更新玩具的价格，但这会被中止。</p>
<p>​ –用户2在回滚之前读取更新。</p>
<h2 id="事务">2 事务</h2>
<p>我们解决这些问题的方法是定义一组关于操作的规则和保证。我们将通过使用事务来实现这一点。transaction1是应作为单个逻辑原子单元执行的多个动作的序列。交易保证ACID特性，以避免上述问题：</p>
<ul>
<li><p>原子性：事务以两种方式结束：提交或中止。原子性意味着Xact中的所有动作都发生，或者没有发生。</p></li>
<li><p>一致性：如果DB开始一致，则在Xact结束时结束一致。</p></li>
<li><p>隔离：每个Xact的执行与其他执行隔离。实际上，DBMS将交错许多XACT的动作，而不是按顺序依次执行。DBMS将确保每个Xact的执行就像它自己运行一样。</p></li>
<li><p>持续性：如果Xact提交，其影响将持续。承诺的Xact的效果必须在失败后仍然存在。</p></li>
</ul>
<h2 id="并发控制">3并发控制</h2>
<p>在本说明中，我们将讨论如何强制执行事务的隔离属性（我们将在关于恢复的说明中了解如何强制执行其他属性）。为此，我们将分析显示操作执行顺序的事务调度。这些操作包括：开始、读取、写入、提交和中止。确保隔离的最简单方法是在开始下一个事务的操作之前，将一个事务中的所有操作运行到完成。这被称为序列计划。例如，以下计划是串行计划，因为T1的操作在T2运行之前完全运行。</p>
<figure>
<img src="/2022/08/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_9/image-20220909224821229.png" alt="image-20220909224821229"><figcaption aria-hidden="true">image-20220909224821229</figcaption>
</figure>
<p>然而，这些调度的问题在于，在启动另一个事务之前等待整个事务完成是没有效率的。理想情况下，我们希望获得与串行调度相同的结果（因为我们知道串行调度是正确的），同时也获得同时运行调度的性能优势。基本上，我们正在寻找一个等同于串行计划的计划。对于等效的明细表，它们必须满足以下三条规则：</p>
<ol type="1">
<li><p>它们涉及相同的事务</p></li>
<li><p>单个事务中的操作顺序相同</p></li>
<li><p>它们都使数据库处于相同的状态</p></li>
</ol>
<p>如果我们找到一个结果等同于串行调度的调度，我们将该调度称为可串行化。例如，以下计划是可序列化的，因为它与上面的计划等效。您可以执行以下计划，并看到资源A和资源B最终具有与上述串行计划相同的值。</p>
<figure>
<img src="/2022/08/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_9/image-20220909225002022.png" alt="image-20220909225002022"><figcaption aria-hidden="true">image-20220909225002022</figcaption>
</figure>
<p>现在的问题是：我们如何确保两个调度使数据库处于相同的最终状态，而不运行整个调度以查看结果？我们可以通过寻找冲突的操作来做到这一点。对于两个冲突的操作，它们必须满足以下三个规则：</p>
<ol type="1">
<li><p>操作来自不同的事务</p></li>
<li><p>两个事务在同一资源上运行</p></li>
<li><p>至少一个操作是写操作</p></li>
</ol>
<p>然后我们检查两个调度是否以相同的方式对每对冲突操作排序。如果他们这样做了，我们可以确定数据库最终将处于相同的最终状态。当两个调度以相同的方式排列其冲突操作时，称为冲突等价，这是比等价更强的条件。</p>
<p>现在，我们有了一种方法来确保两个调度以相同的最终状态离开数据库，我们可以在不运行整个调度的情况下检查一个调度是否与串行调度冲突。我们称之为冲突的调度相当于某些串行调度冲突可串行化。注意：如果调度S是冲突可序列化的，则意味着它是可序列化的。</p>
<h2 id="冲突依赖图">3.1冲突依赖图</h2>
<p>现在，我们有了一种检查时间表是否可序列化的方法！我们可以检查调度是否与某个串行调度冲突等价，因为冲突可序列化意味着可序列化。我们可以通过构建依赖关系图来检查冲突序列化性。依赖关系图具有以下结构：</p>
<ul>
<li><p>每个Xact一个节点</p></li>
<li><p>从<span class="math inline">\(T_i\)</span>到<span class="math inline">\(T_j\)</span>的边缘，如果：</p></li>
</ul>
<p>​ –<span class="math inline">\(Ti\)</span>的操作<span class="math inline">\(O_i\)</span>与<span class="math inline">\(T_j\)</span>的操作<span class="math inline">\(O_j\)</span>冲突</p>
<p>​ –<span class="math inline">\(O_i\)</span>出现在时间表中的时间早于<span class="math inline">\(O_j\)</span></p>
<p>当且仅当其依赖关系图是非循环的时，调度是可冲突序列化的。所以我们所要做的就是检查图是否是非循环的，以确定它是可序列化的！</p>
<p>让我们看两个例子：</p>
<ul>
<li>以下计划是可冲突序列化的，冲突图是非循环的。有两种相互冲突的操作：</li>
</ul>
<p>​ –T1读取A，然后T2写入A。因此，从T1到T2将有一个边沿。</p>
<p>​ –T1向A写入，然后T2从A读取。由于T1到T2之间已经存在一条边，因此我们不必再次添加该边。</p>
<figure>
<img src="/2022/08/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_9/image-20220909225647741.png" alt="image-20220909225647741"><figcaption aria-hidden="true">image-20220909225647741</figcaption>
</figure>
<ul>
<li>以下计划不可冲突序列化，且冲突图不是非循环的。一些冲突操作：</li>
</ul>
<p>​ –T1读取A，然后T2写入A。因此，从T1到T2将有一个边沿。</p>
<p>​ –T2写入B，然后T1读取B。因此，T2到T1之间会有一条边沿。</p>
<figure>
<img src="/2022/08/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_9/image-20220909225737778.png" alt="image-20220909225737778"><figcaption aria-hidden="true">image-20220909225737778</figcaption>
</figure>
<h2 id="结论">4.结论</h2>
<p>在本文中，我们删除了迄今为止的天真假设，即一次只允许一个用户访问数据库。我们讨论了如果我们的数据库不能保证ACID性质，可能出现的潜在异常。我们了解了事务如何是一种强大的机制，用于封装应作为单个逻辑原子单元执行的一系列操作。在下一个注释中，我们将讨论如何为事务调度实际实施冲突序列化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/" class="post-title-link" itemprop="url">数据库————查询优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-20 10:27:27" itemprop="dateCreated datePublished" datetime="2022-08-20T10:27:27+08:00">2022-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:56:11" itemprop="dateModified" datetime="2022-09-15T19:56:11+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="查询优化">查询优化</h1>
<h2 id="导言">1 导言</h2>
<p>当我们讨论SQL时，我们为您提供了一个关于如何执行查询的有用的心理模型。首先在FROM子句中获取所有行，然后在WHERE子句中过滤出不需要的列，依此类推。这很有用，因为它可以确保您将获得查询的正确结果，但数据库实际上并不是这样做的。数据库可以更改它们执行操作的顺序，以获得最佳性能。记住，在这个类中，我们根据I/O的数量来衡量性能。查询优化就是寻找查询计划，以最小化执行查询所需的I/O数量。查询计划只是一系列操作，这些操作将为查询获得正确的结果。我们使用关系代数来表示它。这是查询计划的示例：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909190834709.png" alt="image-20220909190834709"><figcaption aria-hidden="true">image-20220909190834709</figcaption>
</figure>
<p>首先，它将两个表连接在一起，然后过滤掉行，最后只投影所需的列。我们很快就会看到，我们可以提出更好的查询计划！</p>
<h2 id="选择性估计">2.选择性估计</h2>
<p>查询优化的一个重要特性是，在执行一个计划之前，我们无法知道该计划将花费多少I/O。这有两个重要的含义。首先，我们不可能保证找到最佳查询计划-我们只能希望使用启发式和估计找到一个好的（足够的）查询计划。第二，我们需要某种方法来估计查询计划的成本。我们将用来估计查询计划成本的一个工具称为选择性估计。运算符的选择性是一个近似值，表示通过运算符到达其上的运算符的页面百分比。这一点很重要，因为如果我们有一个操作符可以大大减少进入下一阶段的页面数量（如WHERE子句），我们可能希望尽快这样做，以便其他操作符必须处理更少的页面。</p>
<p>大多数选择性估算公式相当简单。例如，为了估计X=3形式的条件的选择性，公式为1/（X的唯一值的数量）。本说明中使用的公式如下所示，但完整列表请参见讲座/讨论幻灯片。在这些示例中，大写字母表示列，小写字母表示常量。以下示例中的所有值都是整数，因为浮点具有不同的公式。</p>
<ul>
<li>X=a: 1/(unique vals in X)</li>
<li>X=Y: 1/max(unique vals in X, unique vals in Y)</li>
<li>X&gt;a: (max(X) - a) / (max(X) - min(X) + 1)</li>
<li>cond1 AND cond2: Selectivity(cond1) * Selectivity(cond2)</li>
</ul>
<h2 id="连接的选择性">3.连接的选择性</h2>
<p>假设我们试图在条件A.id=B.id的情况下将表A和表B连接在一起。如果没有条件，则j结果中会有|A|∗|B |元组，因为没有该条件，A中的每一行都与B中的每行连接。连接条件只是X=Y形式的条件，因此选择性估计为：1/max（A.id的唯一VAL，B.id的惟一VAL），这意味着我们可以期望移动的元组总数为：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909204018789.png" alt="image-20220909204018789"><figcaption aria-hidden="true">image-20220909204018789</figcaption>
</figure>
<h2 id="种常见的启发式方法">4种常见的启发式方法</h2>
<p>对于一个相当复杂的查询，有太多可能的查询计划来分析它们。我们需要一些方法来减少我们实际考虑的计划数量。因此，我们将使用一些启发式方法：</p>
<p>1.尽可能的向下推项目（π）和选择（σ）</p>
<p>2.只考虑剩下的深度计划</p>
<p>3.除非交叉连接是唯一的选项，否则不要考虑交叉连接</p>
<p>第一个启发式方法是，我们将尽可能的投影和选择。我们谈到了为什么进行是有益的。它减少了其他操必须处理的页面数量。但为什么进行投影式有利的呢？事实证明，这也减少了未来操作需要处理的页面数量。由于投影消除了列，行变得更小，这意味着我们可以在一个页面上容纳更多的列，因此页面更少！请注意，您只能投影去除掉查询其余部分中未使用的列（即，如果它们位于尚未计算的SELECT或WHERE子句中，则无法删除该列）。</p>
<p>第二种启发式方法是只考虑左深计划。左深度计划是一个计划，其中联接中的所有右表都是基表（换句话说，右侧永远不是联接本身的结果，它只能是原始表之一）。下图给出了一些示例，说明哪些是深度计划，哪些不是深度计划</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909204944094.png" alt="image-20220909204944094"><figcaption aria-hidden="true">image-20220909204944094</figcaption>
</figure>
<p>左深计划有两个主要原因。首先，只考虑它们会大大减少规划空间。计划空间仍然是指数级的，但比我们考虑每个计划时要小得多。其次，这些计划可以完全流水线化，这意味着我们可以将页面一次一个地传递给下一个连接操作符——实际上我们不必将连接的结果写入磁盘。</p>
<p>第三种启发式是有益的，因为交叉连接产生大量页面，这使得交叉连接上方的运算符执行许多I/O。我们希望尽可能避免这种情况。</p>
<h2 id="系统r的第1遍">5 系统R的第1遍</h2>
<p>我们将在这个类中学习的查询优化器称为System R。System R使用我们在上一节中提到的所有启发式方法。系统R的第一步决定了如何以最佳方式或有趣的方式访问表（我们将稍微定义有趣）。</p>
<p>我们有两种方法可以在第一次访问时访问表：</p>
<ol type="1">
<li><p>全表扫描</p></li>
<li><p>索引扫描（对于表在其上构建的每个索引）</p></li>
</ol>
<p>对于这两种扫描，由于第一种启发式（下推选择操作），我们只返回一行，如果它匹配与其表相关的所有单表条件。涉及来自多个表的列的条件是联接条件，并且还不能应用，因为我们只考虑如何访问单个表。这意味着每种扫描类型的选择性是相同的，因为它们应用相同的条件！</p>
<p>然而，每种类型的扫描所需的I/O数量将不相同。对于表P，全扫描将始终采用[P]I/O；每一页都需要阅读。</p>
<p>对于索引扫描，I/O的数量取决于记录的存储方式以及索引是否群集。备选1指数的IO成本为：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909205717449.png" alt="image-20220909205717449"><figcaption aria-hidden="true">image-20220909205717449</figcaption>
</figure>
<p>您不必读取每个叶，因为您可以应用与索引所基于的列相关的条件。这是因为数据在叶中是按排序顺序排列的，因此您可以直接转到应该开始的叶，然后可以直接扫描，直到条件不再为真。</p>
<p>示例：重要信息：</p>
<ul>
<li><p>表A有[A]页</p></li>
<li><p>有一个高度为2的C1的备选方案1索引</p></li>
<li><p>我们的查询中有两个条件：C1&gt;5 and C2&lt;6</p></li>
<li><p>C1和C2的值都在1-10范围内</p></li>
</ul>
<p>选择性将是0.25，因为两个条件的选择性都是0.5（根据选择性公式），这是一个and子句，所以我们将它们相乘。然而，我们不能使用C2条件来缩小我们在索引中查看的页面，因为索引不是建立在C2上的。我们可以使用C1条件，因此我们只需要查看0.5[A]叶页面。我们还必须读取两个索引页，以找到从哪个叶开始，总共2+0.5[a]个I/O。</p>
<p>对于备选2/3指数，公式略有不同。新公式为：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909205919692.png" alt="image-20220909205919692"><figcaption aria-hidden="true">image-20220909205919692</figcaption>
</figure>
<p>我们可以对读取的叶节点数和读取的数据页数应用选择性（针对建立索引的列的条件）。对于聚集索引，读取的数据页数是选择性乘以数据页总数。但是，对于非群集索引，您必须为每个记录执行IO，因此它是选择性乘以记录总数。</p>
<p>示例：重要信息：</p>
<ul>
<li><p>带有[B]数据页和|B|记录的表B</p></li>
<li><p>列C1上的备选方案 2索引，高度为2页和[L]个叶子页</p></li>
<li><p>有两种情况：C1&gt;5 and C2&lt;6</p></li>
<li><p>C1和C2的值都在1-10范围内</p></li>
</ul>
<p>如果索引是聚集的，则扫描将需要2个I/O才能到达叶级以上的索引节点，然后必须读取0.5[L]叶页，然后读取0.5[B]数据页。因此，总数为2+0.5[L]+0.5[B]。如果索引未群集，则公式相同，只是我们必须读取0.5 |B|数据页。因此，I/O的总数为2+0.5[L]+0.5|B|。</p>
<p>pass 1的最后一步是决定我们将推进到后续通行证以供考虑的访问计划。对于每个表，我们将提出最佳访问计划（需要最少数量I/O的访问计划）和任何产生最佳有趣顺序的访问计划。一个有趣的顺序是当表按列排序时：</p>
<ul>
<li><p>在ORDER BY中使用</p></li>
<li><p>在GROUP BY中使用</p></li>
<li><p>用于下游联接（尚未评估的联接。对于第1次传递，这是所有联接）。</p></li>
</ul>
<p>前两个是显而易见的。最后一种方法很有价值，因为它可以让我们在查询执行过程中减少排序合并连接所需的I/O数量。完整扫描永远不会产生有趣的顺序，因为其输出未排序。然而，索引扫描将在建立索引的列上按排序顺序生成输出。请记住，只有在稍后的查询中使用此顺序时，才会变得interesting！</p>
<p>示例：假设我们正在评估以下查询：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909210621466.png" alt="image-20220909210621466"><figcaption aria-hidden="true">image-20220909210621466</figcaption>
</figure>
<p>我们有以下潜在的访问模式：</p>
<ol type="1">
<li>Full Scan players (100 I/Os)</li>
<li>Index Scan players.age (90 I/Os)</li>
<li>Index Scan players.teamid (120 I/Os)</li>
<li>Full Scan teams (300 I/Os)</li>
<li>Index Scan teams.record (400 I/Os)</li>
</ol>
<p>模式2、3和4将可行。模式2和4是它们各自表的最佳模式，模式3有一个有趣的顺序，因为teamid用于下游连接。</p>
<h2 id="passes-2..n">6 Passes 2..n</h2>
<p>系统R算法的其余过程涉及将表连接在一起。对于每个Pass i，我们尝试使用Pass i-1和Pass1的结果将 i 个表连接在一起。例如，在Pass 2，我们将尝试将两个表连接到一起，每个表来自Pass1。在Pass5，我们将试图将总共5个表连接起来。我们将从第4遍中得到其中的4张表（它指出了如何将4张表连接在一起），并从第1遍中得到剩余的表。请注意，这强制了我们的左深度计划启发式。我们总是用一个基表连接一组连接表。</p>
<p>Pass i 将为长度为 i 的所有表集生成至少一个查询计划，这些表集可以在没有交叉联接的情况下联接（假设至少有一个这样的集合）。就像在第1步中一样，它将为每个集合提出最优计划，也为每个集合（如果存在）的每个有趣顺序提出最优计划。当尝试将一组表与第1次Pass中的一个表联接时，我们将考虑数据库已实现的每个联接。这些联接中只有一个联接产生排序输出-排序合并联接，因此获得有趣顺序的唯一方法是对集合中的最后一个联接使用排序合并联接。排序合并联接的输出将按联接条件中的列进行排序。</p>
<p>示例：我们正在尝试执行以下查询：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909211138813.png" alt="image-20220909211138813"><figcaption aria-hidden="true">image-20220909211138813</figcaption>
</figure>
<p>在第2遍中，我们将返回哪些表集的查询计划？在本次传递中，我们将考虑的表集只有｛A，B｝和｛B，C｝。我们不考虑{A，C}，因为没有连接条件，我们的启发式告诉我们不要考虑交叉连接。为了简化问题，假设我们在数据库中只实现了SMJ和BNLJ，并且pass 1只返回每个表的完整表扫描。以下是我们将考虑的连接（成本由问题补偿。实际上，您将使用选择性估计和连接成本公式）：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909211312451.png" alt="image-20220909211312451"><figcaption aria-hidden="true">image-20220909211312451</figcaption>
</figure>
<p>联接1、5和6可行。1是集合｛A，B｝的最佳连接。5对于集合{B，C}是最优的。6是一个有趣的顺序，因为有一个order BY子句，在查询中稍后使用c.cid。我们不提前3，因为A.aid和B.bid在连接后不使用，因此顺序不有趣。</p>
<p>现在让我们转到第3步。我们将考虑以下连接（连接成本也是由连接成本组成的）：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909211455670.png" alt="image-20220909211455670"><figcaption aria-hidden="true">image-20220909211455670</figcaption>
</figure>
<p>请注意，现在我们不能更改连接顺序，因为我们只考虑左深度计划，所以基表必须在右侧。</p>
<p>现在唯一可以推进的计划是2和3。对于所有3个表的集合，3是最优的。2对于C.cid上具有有趣顺序的所有3个表的集合是最佳的（这仍然很有趣，因为我们没有评估order BY子句）。产生按C.cid排序的输出的原因是连接条件为B.did=C.cid，因此输出将按B.did和C.ci排序（因为它们相同）。4和6将不会产生按C.cid排序的输出，因为它们将把A添加到联接表集合中，因此条件将是A.aid=B.bid。A.aid和B.bid都没有在查询的其他地方使用，因此它们的排序对我们来说并不有趣。</p>
<h2 id="计算联接操作的io成本">7.计算联接操作的I/O成本</h2>
<p>当我们估计我们试图优化的查询的I/O成本时，重要的是考虑以下几点：</p>
<ol type="1">
<li><p>我们是具体化中间关系（来自先前运算符的输出）还是将它们流式传输到下一个运算符的输入。</p></li>
<li><p>如果从以前的操作符获得的有趣命令可以减少执行联接的I/O成本</p></li>
</ol>
<p>由于这些考虑，我们可能无法直接使用迭代器和连接模块中的公式来计算I/O成本。</p>
<h3 id="考虑因素-1">7.1 考虑因素 1</h3>
<p>无论是具体化中间关系（先前运算符的输出）还是将它们流式传输到下一个运算符的输入，都会影响查询的I/O成本。</p>
<p>为了具体化中间关系，我们将中间运算符的输出写入磁盘（即，将其写入临时文件），这一过程会导致额外的i/O。当这些数据传递到下一个操作员时，我们必须再次将其从磁盘读取到内存中。另一方面，如果我们将一个操作符的输出流到下一个操作符中，我们不会将中间输出写入磁盘。相反，当我们处理第一个运算符时，元组一旦可用，它们就会保留在内存中，我们开始对它们应用第二个运算符。</p>
<p>例如，当我们下推选择/投影时，我们的目标是减少数据的大小，以便在树上遍历时，需要更少的I/O来读取数据。然而，如果这些选择/预测的输出被具体化，或者如果我们执行的下一个运算符仅通过数据一次（即，S/P/BNLJ的左关系、INLJ的右关系等），我们将只看到I/O成本的影响。为了说明这一点，我们来看下面的示例。</p>
<p>例子：</p>
<p>假设B=5，[P]=50，[T]=100，有30页的玩家记录，其中P.teamid&gt;200，有40页的记录，其中T.tname&gt;Team5。我们正在优化以下内容：</p>
<p>查询：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909211934475.png" alt="image-20220909211934475"><figcaption aria-hidden="true">image-20220909211934475</figcaption>
</figure>
<p>假设我们的查询优化器选择了以下查询计划：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909211959068.png" alt="image-20220909211959068"><figcaption aria-hidden="true">image-20220909211959068</figcaption>
</figure>
<p>此查询计划的估计I/O成本为<span class="math inline">\(（50+30）+（100+40）+（30+\lceil \frac{30}{5-2} \rceil*40）= 650\)</span></p>
<p>我们首先对P执行完全扫描：我们读取P的所有50页，识别P.teamid＞200的记录，并将这些记录的30页写入磁盘。发生这种情况是因为我们正在具体化选择后得到的输出。我们对T重复相同的过程：我们读入T的所有100页，识别T.tname＞Team5的记录，并将这些记录的40页写入磁盘。</p>
<p>接下来，当我们使用BNLJ将这两个表连接在一起时，我们正在处理30页的P和40页的T，这些选择已经应用到并且当前位于磁盘上。对于P的每个B-2页块，我们读取所有T，因此$（30+ ) $ 轮</p>
<p>现在，假设我们的查询优化器选择了以下查询计划</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909212345684.png" alt="image-20220909212345684"><figcaption aria-hidden="true">image-20220909212345684</figcaption>
</figure>
<p>此查询计划的估计I/O成本为<span class="math inline">\(（50+30）+（30+ \lceil \frac{30}{5-2}\rceil * 100) = 1110\)</span> I/O</p>
<p>由于我们在P上执行选择后实现了我们得到的输出，我们首先读取P的所有50页，识别P.teamid＞200的记录，并将这些记录的30页写入磁盘。</p>
<p>我们将在选择大小为B-2的块后读取剩余的30页P。对于每个P块，我们需要识别T中的匹配记录。由于我们在选择tname＜“Team5”的记录后没有具体化，因此我们必须对每个P块的整个T表执行完整扫描，逐页将T读取到内存中，找到tname＜‘Team5‘所在的记录，并在P中加入他们的记录。有<span class="math inline">\(\lceil \frac{30}{5-2}\rceil\)</span> 个P中的块需要处理，因此需要<span class="math inline">\(\lceil \frac{30}{5-2}\rceil * 100\)</span> 轮</p>
<p>在这里，我们看到，即使我们在T上下推选择，它也不会影响查询的I/O成本。如果使用此查询计划，则I/O成本将相同：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909215244521.png" alt="image-20220909215244521"><figcaption aria-hidden="true">image-20220909215244521</figcaption>
</figure>
<p>I/O成本保持不受影响的原因是，每次我们通过T（每P块一次），我们仍然需要访问整个T表并动态应用选择，因为我们没有保存这些中间结果。这表明，只有当下一个操作员对数据进行单次传递时，或者当中间关系的输出被具体化时，下推选择/投影如何影响我们的I/O成本。</p>
<p>对于我们在这个类中研究的System R查询优化器，假设我们从未具体化任何中间运算符的输出，并且它们作为下一个运算符的输入流。</p>
<p>因此，这是System R查询优化器将考虑的查询计划：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909215355957.png" alt="image-20220909215355957"><figcaption aria-hidden="true">image-20220909215355957</figcaption>
</figure>
<p>此查询计划的估计I/O成本为 <span class="math inline">\(50+\lceil \frac{30}{5-2}\rceil* 100 = 1050\)</span> I/O</p>
<p>我们对P执行全扫描，将50页中的每一页读取到内存中，并过滤P.teamid＜200的记录。由于我们按下此选择，只有30页P将传递到BNLJ运算符。对于P的每个B-2页块，其中P.teamid＜200，我们需要识别T中的匹配记录。由于我们在选择tname＜Team5的记录后没有实现，我们将不得不对P的每个块的整个T表执行完整扫描，逐页读取T到内存中，找到tname＜‘Team5’的记录，并将它们与P中的记录连接。P中有<span class="math inline">\(\lceil\frac{30}{5-2}\rceil\)</span> 个块需要处理，因此需要<span class="math inline">\(\lceil\frac{30}{5-2}\rceil* 100\)</span> 轮。</p>
<h3 id="考虑因素-2">7.2 考虑因素 2</h3>
<p>我们还必须考虑来自先前操作符的有趣命令的影响。例如，假设我们正在优化以下查询，其中玩家表包含50页，团队表包含100页：</p>
<figure>
<img src="/2022/08/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_8/image-20220909220525735.png" alt="image-20220909220525735"><figcaption aria-hidden="true">image-20220909220525735</figcaption>
</figure>
<p>假设我们按下选择P.teamid&gt;200，选择对P.Team ID的索引扫描，花费60 I/O作为我们对P表的访问计划，并选择花费100 I/O的完整扫描作为我们对T表的访问方案。索引扫描的输出将按teamid排序，这是一个有趣的顺序，因为它可能用于P和T之间的下游连接。</p>
<p>现在，假设我们选择SMJ作为连接P和T的连接算法。我们在迭代器和连接模块中给出的公式将估计I/O成本为：排序P的成本+排序T+（50+100）的成本，其中最后一项（[P]+[T]）是合并步骤的平均案例成本，并考虑了两个表中的读取成本。</p>
<p>然而，如果我们在P.teamid上使用索引扫描，我们不再需要在P上运行外部排序！相反，我们将考虑使用索引扫描访问P的I/O成本，并在合并阶段的索引扫描输出中使用流。因此，该查询计划的估计成本为（T的排序成本+60+100）I/O的成本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/" class="post-title-link" itemprop="url">数据库————迭代器和连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-15 10:27:27" itemprop="dateCreated datePublished" datetime="2022-08-15T10:27:27+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:55:54" itemprop="dateModified" datetime="2022-09-15T19:55:54+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="迭代器和连接">迭代器和连接</h1>
<h2 id="导言">1 导言</h2>
<p>让我们从最简单的问题开始：连接到底是什么？如果您还记得SQL项目，您将记得在R.name=S.name上编写R内部连接S和其他类似的语句。</p>
<p>实际上，这意味着，你需要两个关系，R和S，并从它们在连接条件上的匹配中创建一个新关系——也就是说，对于R中的每个记录<span class="math inline">\(r_i\)</span>，找到S中与我们指定的连接条件匹配的所有记录<span class="math inline">\(s_j\)</span>，并将＜<span class="math inline">\(r_i\)</span>，<span class="math inline">\(s_j\)</span>＞写入输出中的新行（R的所有字段后面跟着S的所有字段）。SQL讲座幻灯片是一个很好的资源，可以让您更清楚地了解连接实际上是什么。</p>
<p>在讨论不同的连接算法之前，我们需要讨论当由＜<span class="math inline">\(r_i\)</span>，<span class="math inline">\(s_j\)</span>＞组成的新连接关系形成时会发生什么。无论何时计算联接的成本，我们都会忽略将联接关系写入磁盘的成本。这是因为我们假设连接的输出将被稍后执行SQL查询时涉及的另一个操作符使用。通常，此运算符可以直接从内存中使用连接的记录。如果这听起来让人困惑，不要担心；我们将在查询优化模块中重新讨论它，但现在需要记住的重要一点是，最终写入成本不包括在联接成本模型中</p>
<p>求和并没有告诉我们任何我们不知道的事情；我们需要通过每一轮，准确地找出读写的内容。最后的2X部分表示，为了构建哈希表，我们需要在分区通过后读取和写入每个页面。</p>
<p>以下是一些重要属性：</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220912160812006.png" alt="image-20220912160812006"><figcaption aria-hidden="true">image-20220912160812006</figcaption>
</figure>
<p>属性1表示我们必须在第一次分区过程中读取每个页面。这直接来自算法。</p>
<p>属性2表示，在分区过程中，我们将写出至少与读入一样多的页面。这直接来自上面的解释——我们可以在分区过程中创建额外的页面。</p>
<p>属性3表示我们不会读取比之前分区过程中写入的页面更多的页面。在最坏的情况下，pass i中的每个分区都需要重新分区，因此这需要我们读取每个页面。然而，在大多数情况下，一些分区将足够小，以容纳内存，因此我们可以读取比上一次生成的页面更少的页面。</p>
<p>属性4表示我们将构建哈希表的页面数量至少与我们开始时的数据页面数量一样多。这是因为分区过程只能增加数据页的数量，而不能减少它们。</p>
<h2 id="简单嵌套循环连接-snlj">2 简单嵌套循环连接 SNLJ</h2>
<p>让我们从最简单的策略开始。假设我们有一个B页缓冲区，我们希望在连接条件θ下连接两个表R和s。从最自然的策略开始，我们可以在R中获取每个记录，在S中搜索其所有匹配项，然后生成每个匹配项。</p>
<p>这称为简单嵌套循环连接（SNLJ）。您可以将其视为两个嵌套的for循环：</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220908232319911.png" alt="image-20220908232319911"><figcaption aria-hidden="true">image-20220908232319911</figcaption>
</figure>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220908232327205.png" alt="image-20220908232327205"><figcaption aria-hidden="true">image-20220908232327205</figcaption>
</figure>
<p>这将是一件很好的事情，但该类的主题实际上是围绕优化和最小化I/O。因此，这是一个非常糟糕的方案，因为我们在R中获取每个记录，并在S中读取每个页面以搜索匹配项。这样做的I/O成本将是[R]+|R|[S]，其中[R]是R中的页数，|R|是R中记录的数量。虽然我们可以通过在for循环中切换R和S的顺序来稍微优化，但这确实不是一个很好的策略。</p>
<p>注意：SNLJ不会产生|R| I/o来读取R中的每一条记录。这将花费[R]I/o，因为它实际上更像是“R中的每个页面<span class="math inline">\(p_r\)</span>:<span class="math inline">\(p_r\)</span>中的每个记录r:S中的每个页<span class="math inline">\(p_s\)</span>:<span class="math inline">\(p_s\)</span>中每个记录s:join”，因为我们不能一次读取少于一页。</p>
<h2 id="页嵌套循环连接-pnlj">3 页嵌套循环连接 PNLJ</h2>
<p>很明显，我们不想为R的每一条记录读取S的每一页，那么我们能做得更好吗？如果我们读S中的每一页，而读R中的每页，会怎么样？也就是说，对于R的一页，获取所有记录并将它们与S中的每个记录进行匹配，然后对R的每一页执行此操作。</p>
<p>这称为页面嵌套循环连接（PNLJ）。下面是它的伪代码：</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909131338267.png" alt="image-20220909131338267"><figcaption aria-hidden="true">image-20220909131338267</figcaption>
</figure>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909131345156.png" alt="image-20220909131345156"><figcaption aria-hidden="true">image-20220909131345156</figcaption>
</figure>
<p>这样的I/O成本稍微好一些。它是[R]+[R][S]——这可以通过保持R和S之间的较小关系作为外部关系来优化。</p>
<h2 id="块嵌套循环连接-bnlj">4 块嵌套循环连接 BNLJ</h2>
<p>页面嵌套循环连接更好！唯一的问题是我们仍然没有尽可能充分地利用缓冲区。我们有B个缓冲页，但我们的算法只使用了3个缓冲页——一个用于R，一个用于S，另一个用于输出缓冲区。请记住，我们在S中读取的次数越少越好——因此，如果我们可以为R保留B-2页，并将S与每个“块”中的每个记录进行匹配，我们可以大幅降低I/O成本！</p>
<p>这称为块嵌套循环联接（或块嵌套循环连接）。这里的关键思想是，我们希望利用缓冲区来帮助我们降低I/O成本，因此我们可以为R块保留尽可能多的页面——因为我们每个块只读取S的每个页面一次，更大的块意味着更少的I/O。对于R的每个块，将S中的所有记录与块中的所有纪录进行匹配。</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909141835493.png" alt="image-20220909141835493"><figcaption aria-hidden="true">image-20220909141835493</figcaption>
</figure>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909141910482.png" alt="image-20220909141910482"><figcaption aria-hidden="true">image-20220909141910482</figcaption>
</figure>
<p>然后，其I/O成本可以写为</p>
<p><span class="math inline">\([R] + \lceil \frac{[R]}{B-2} \rceil[S]\)</span></p>
<p>这好多了！现在，我们利用我们的B缓冲页来减少我们必须在S中读取的次数。</p>
<h2 id="索引嵌套循环连接-inlj">5 索引嵌套循环连接 INLJ</h2>
<p>然而，有时块嵌套循环连接不是最好的选择。有时，如果我们在S上有一个索引，该索引位于适当的字段（即我们要加入的字段）上，则在S中查找<span class="math inline">\(r_i\)</span>的匹配可能非常快。这称为索引嵌套循环连接，伪代码如下：</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909143010579.png" alt="image-20220909143010579"><figcaption aria-hidden="true">image-20220909143010579</figcaption>
</figure>
<p>I/O成本为[R]+|R|∗（以S为单位查找匹配记录的成本）。</p>
<p>在S中查找匹配记录的成本将因索引类型而异。如果它是一个B+树，我们将从根开始搜索，并计算需要多少I/O才能到达相应的记录。请参阅B+树课程笔记中的群集和计数I/O部分。</p>
<h2 id="哈希连接-shj-ghj">6 哈希连接 SHJ GHJ</h2>
<p>请注意，在整个序列中，我们确实在寻找匹配的记录。不过，哈希表非常适合查找匹配项；即使我们没有索引，我们也可以在R的记录上构造一个B-2页2大的哈希表，将其放入内存，然后读入S的每个记录，并在R的哈希表中查找，看看是否可以找到任何匹配项。这称为朴素哈希连接。其成本为[R]+[S] I/O。</p>
<p>这实际上是我们做过的最好的一次。它高效、廉价、简单。然而，这有一个问题；这依赖于R能够完全适应内存（具体而言，R是≤ B− 2页大）。这通常是不可能的。</p>
<p>为了解决这个问题，我们反复将R和S散列到B-1缓冲区中，这样我们就可以得到≤ B− 2页大，使我们能够将它们放入内存并执行简单的哈希连接。更具体地，考虑每对对应的分区<span class="math inline">\(R_i\)</span>和<span class="math inline">\(S_i\)</span>（即R的分区i和S的分区i）。如果<span class="math inline">\(R_i\)</span>和<span class="math inline">\(S_i\)</span>都大于B-2页，则将两个分区散列为较小的分区。否则，如果<span class="math inline">\(R_i\)</span>或<span class="math inline">\(S_i\)</span>≤ B-2页，停止分区并将较小的分区加载到内存中，以构建内存哈希表，并与该对中的较大分区执行朴素哈希连接。</p>
<p>此过程称为Grace哈希连接，其I/O成本为：哈希的成本加上子节上的原始哈希连接的成本。散列的成本可以根据我们需要在多少分区上重复散列多少次而变化。散列分区P的成本包括我们需要读取P中所有页面的I/O，以及我们需要在散列分区P之后写入所有结果分区的I/I。</p>
<p>每个分区对的朴素散列连接部分成本是完成后在两个分区中读取每个页面的成本。</p>
<p>Grace散列很好，但它对密钥偏移非常敏感，所以在使用该算法时要小心。密钥歪斜是当我们尝试散列但许多密钥进入同一个桶时。当许多记录具有相同的密钥时，会发生密钥偏移。例如，如果我们对只包含“yes”作为值的列进行散列，那么我们可以继续散列，但无论使用哪个散列函数，它们都会在同一个桶中结束。</p>
<p>每个分区对的朴素散列连接部分成本是完成后在两个分区中读取每个页面的成本。</p>
<p>Grace散列很好，但它对密钥偏移非常敏感，所以在使用该算法时要小心。密钥歪斜是当我们尝试散列但许多密钥进入同一个桶时。当许多记录具有相同的密钥时，会发生密钥偏移。例如，如果我们对只包含“yes”作为值的列进行散列，那么我们可以继续散列，但无论使用哪个散列函数，它们都会在同一个桶中结束。</p>
<h2 id="排序合并联接-smj">7 排序合并联接 SMJ</h2>
<p>有时，我们可以先对R和S进行排序，特别是当我们希望我们的联接表按特定列排序时。在这些情况下，我们首先对R和S进行排序，然后：</p>
<ol type="1">
<li>我们从R和S的开始处开始，前进一个或另一个，直到我们完成一次匹配（如果<span class="math inline">\(r_i\)</span>＜<span class="math inline">\(s_j\)</span>，则前进R；否则如果<span class="math inline">\(r_i\)</span>＞<span class="math inline">\(s_j\)</span>，前进S–我们的想法是前进两个中较小的一个，直至我们完成一次匹配）。</li>
<li>现在，让我们假设我们得到了一个匹配。假设这对是<span class="math inline">\(r_i\)</span>，<span class="math inline">\(s_j\)</span>。我们将S中的这一点标记为标记（s），并检查s中的每个后续记录（<span class="math inline">\(s_j\)</span>，<span class="math inline">\(s_j\)</span>+1，<span class="math inline">\(s_j\)</span>+2等），直到找到不匹配的记录（即读取S中与<span class="math inline">\(r_i\)</span>匹配的所有记录）。</li>
<li>现在，转到R中的下一个记录，返回到S中的标记点，并在步骤1再次开始（除了不是从R的开始和S的开始，而是在我们刚刚指出的索引处开始），其思想是，因为R和S被排序，所以R的任何未来记录的任何匹配都不能在S中的标定点之前，因为该记录<span class="math inline">\(r_i\)</span>+1≥ <span class="math inline">\(r_i\)</span>–如果<span class="math inline">\(r_i\)</span>的匹配项在标记之前不存在，则<span class="math inline">\(r_i\)</span>+1的匹配项也不可能在标记之前存在！因此，我们从S中的标记点开始滚动，直到找到<span class="math inline">\(r_i\)</span>+1的匹配项。</li>
</ol>
<p>这称为排序合并连接，平均I/O成本为：排序R的成本+排序S+（[R]+[S]）（但需要注意的是，这不是最坏的情况！）。在最坏的情况下，如果R的每个记录都与S的每个记录匹配，则最后一项变成|R|∗ [S] 。最坏情况下的成本是：排序R的成本+排序S+的成本（[R]+|R|）∗ [S] ）。但这通常不会发生）。</p>
<p>让我们看一个例子。让左边的表是R，右边的表是S。</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909184627842.png" alt="image-20220909184627842"><figcaption aria-hidden="true">image-20220909184627842</figcaption>
</figure>
<p>我们将在S上前进指针（红色箭头），因为28＜31，直到S到达31的sid。然后我们将标记此记录（黑色箭头）。此外，我们将输出此匹配。</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909185018084.png" alt="image-20220909185018084"><figcaption aria-hidden="true">image-20220909185018084</figcaption>
</figure>
<p>然后我们将再次将指针前进到S上，并获得另一个匹配并输出它。</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909185040859.png" alt="image-20220909185040859"><figcaption aria-hidden="true">image-20220909185040859</figcaption>
</figure>
<p>我们再次将指针前进到S上，但没有得到匹配。然后我们将S重置到标记的位置（黑色箭头），然后前进R。当我们前进R时，我们得到另一个匹配，因此我们输出它。</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909185133682.png" alt="image-20220909185133682"><figcaption aria-hidden="true">image-20220909185133682</figcaption>
</figure>
<p>然后我们前进S，得到另一个匹配，然后输出它。</p>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909185202374.png" alt="image-20220909185202374"><figcaption aria-hidden="true">image-20220909185202374</figcaption>
</figure>
<figure>
<img src="/2022/08/15/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_7/image-20220909185211315.png" alt="image-20220909185211315"><figcaption aria-hidden="true">image-20220909185211315</figcaption>
</figure>
<h2 id="重要的改进">7.1重要的改进</h2>
<p>一个重要的改进：您可以将最后一个排序阶段与合并阶段结合起来，前提是您有足够的内存空间为每次运行[R]和每次运行[S]分配一个页面。最后的合并过程是为每次运行R和每次运行S分配一个页面。在此过程中，您节省2∗ （[R]+[S]）I/O</p>
<p>要执行优化，我们必须 :</p>
<ol type="1">
<li><p>对[R]和[S]进行排序（分别使用它们的完整缓冲池），直到它们都“几乎已排序”；也就是说，对于｛R，S｝中的每个表T，继续合并T的运行，直到到达倒数第二步，其中再进行一次排序将导致排序表T。</p></li>
<li><p>查看剩余[R]的运行次数和[S]的运行数量；把他们加起来。为每次运行分配一页内存。如果您有足够的输入缓冲区来容纳它（即，如果运行（R）+运行（S））≤ B− 1） ，则可以使用优化，然后可以节约2∗ （[R]+[S]）I/O。</p></li>
<li><p>如果您无法进行上一步中描述的优化，则意味着runs（R）+runs（S）≥ B、 在理想情况下，优化允许我们避免对R和S进行额外的读取，但这在这里是不可能的，因为我们没有针对R和S的每次运行的可用缓冲区。</p></li>
</ol>
<p>然而，我们还没有选择！如果我们不能避免R和S的额外读取，也许我们可以避免其中至少一个的额外读取。因为我们试图最小化I/O，我们希望避免对较大的表R进行额外的读取。它是否可以帮助我们对较小的表S进行完全排序，并将其用于优化？</p>
<p>事实证明我们可以！如果我们对S进行完全排序，根据定义，现在该表只有一次排序运行，这意味着我们只需要在缓冲区中为它分配一个页面。因此，如果运行（R）+1≤ B− 1，然后我们可以为S和R的每次运行分配一个缓冲页。然后，我们可以执行SMJ优化。在这里，我们通过将R与连接阶段相结合，避免了R的最终排序过程。所以我们节省了2∗[R] 页面。</p>
<p>但是，有时，即使这样也不够——如果运行（R）=B-1，那么我们没有用于S的备用缓冲页。在这种情况下，我们仍然希望尽可能减少I/O，因此可能执行上一段中描述的过程，但对于较小的表。即，如果运行（S）+1≤ B− 1，然后对R进行排序，根据定义将其排序运行的数量减少到1，然后为R分配一个缓冲页，为S的每次运行分配一个。然后，执行优化–这将使我们能够通过将其与连接阶段相结合来避免S的最终排序过程，从而节省2∗ [S] I/O。</p>
<p>但是，如果这些条件都不满足，我们将无法优化排序合并联接。没关系。有时候，我们不得不忍着风险，接受我们不能总是走捷径。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/" class="post-title-link" itemprop="url">数据库————哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-10 10:27:27" itemprop="dateCreated datePublished" datetime="2022-08-10T10:27:27+08:00">2022-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:55:39" itemprop="dateModified" datetime="2022-09-15T19:55:39+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="哈希">哈希</h1>
<h2 id="动机">1 动机</h2>
<p>有时，排序对于这个问题来说有点过分。在许多情况下，我们只想将相同的值分组在一起，但实际上并不关心值的出现顺序（考虑分组方式或重复数据消除）。在数据库中，将类似的值分组在一起称为哈希。我们无法以您在61B中学习的标准方式构建哈希表，原因与我们无法在最后一个注释中使用快速排序相同；我们无法将所有数据存储在内存中！让我们看看如何构建一个高效的基于外存的散列算法。</p>
<h2 id="总体战略">2 总体战略</h2>
<p>因为我们不能一次将所有数据放入内存，所以我们需要构建几个不同的哈希表并将它们连接在一起。但这个想法有一个问题。如果我们构建两个单独的哈希表，每个哈希表中都有相同的值（例如，“Brian”出现在两个表中），会发生什么？连接这些表将导致一些“Brian”不在彼此旁边。</p>
<p>为了解决这个问题，在用内存中的数据构建哈希表之前，我们需要保证，如果某个值在内存中，那么它的所有出现都在内存中。换句话说，如果“Brian”至少在内存中出现一次，那么我们只能在数据中每次出现“Brian”，当前都在内存中的情况下构建哈希表。这确保了值只能出现在一个哈希表中，从而使哈希表可以安全连接。</p>
<h2 id="算法">3 算法</h2>
<p>我们将使用分而治之的算法来解决这个问题。“划分”阶段将划分传递，“控制”阶段将实际构建哈希表。就像在排序注释中一样，我们假设我们有B个缓冲帧可用</p>
<p>第一次分区传递将每个记录散列到B− 1个分区。分区是一组页面，使得页面上的值都散列为相同的值（对于用于构造分区的散列函数）。我们通过使用B− 1输出缓冲器来实现这一点。当输出缓冲区填满时，我们将页面刷新到磁盘。当下一次缓冲区填满时，我们将其放置在之前从同一缓冲区刷新到磁盘的页面旁边。每个分区最重要的属性是，如果某个值出现在该分区中，那么数据中该值的所有出现都会出现在该区域中。换句话说，如果“Brian”出现在该分区中，“Brian”将不会出现在任何其他分区中。这是因为“Brian”总是散列到相同的值，因此它不可能在不同的分区中结束。我们只有B− 1分区，因为我们需要保存一个缓冲帧作为输入缓冲区。</p>
<p>在第一次分区之后，我们可以直接进入哈希表构建阶段，为适合内存的分区构建哈希表。内存匹配是什么意思？内存匹配意味着分区必须小于等于B页。对于太大的分区，我们只需使用与第一次使用的哈希函数不同的哈希函数来重新分区。为什么要使用不同的哈希功能？如果我们重用原始函数，每个值都会散列到其原始分区，因此分区不会变小。我们可以根据需要进行多次递归分区，直到所有分区最多有B个页面。</p>
<p>现在我们所有的分区都可以放在内存中，我们知道所有类似的值都出现在同一个分区中。剩下要做的就是为每个分区构建一个哈希表，并将每个哈希表写入磁盘。</p>
<h2 id="例子">4 例子</h2>
<p>在下面的示例中，我们将假设我们有B=3个可用的缓冲页。我们还假设Brian和Eric对第一个哈希函数的值相同，但对第二个哈希函数使用不同的值，Jamie和Lakshya对第一个hash函数使用相同的值。</p>
<figure>
<img src="/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/image-20220908224458144.png" alt="image-20220908224458144"><figcaption aria-hidden="true">image-20220908224458144</figcaption>
</figure>
<p>您可以看到分区0太大，因为它包含4个页面，但我们只有3个缓冲帧可用。然而，当它被递归分区时，子分区（0.a和0.b）都只有2页长，因此它们现在可以放入内存。您还可以看到，在最后一次“控制”之后，所有类似的值都彼此相邻，这是我们的最终目标。</p>
<h2 id="外部哈希分析">5 外部哈希分析</h2>
<p>我们不能像排序算法那样创建一个简单的公式来计算I/O的数量，因为我们不知道分区有多大。我们首先需要认识到的一点是，在分区通过后，表中的页面数可能会增加。要了解原因，请考虑下表，其中我们可以在一个页面上拟合两个整数：</p>
<figure>
<img src="/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/image-20220912160235801.png" alt="image-20220912160235801"><figcaption aria-hidden="true">image-20220912160235801</figcaption>
</figure>
<p>假设B=3，因此我们只将数据划分为2个分区。假设1和3哈希到分区1，2和4哈希到分区2。分区后，分区1将具有：</p>
<figure>
<img src="/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/image-20220912160309822.png" alt="image-20220912160309822"><figcaption aria-hidden="true">image-20220912160309822</figcaption>
</figure>
<p>分区2将有：</p>
<figure>
<img src="/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/image-20220912160332326.png" alt="image-20220912160332326"><figcaption aria-hidden="true">image-20220912160332326</figcaption>
</figure>
<p>请注意，我们现在只有4个页面，而我们刚开始时只有3个页面。因此，计算I/O数量的唯一可靠方法是遍历每一轮，查看将读取和写入的内容。设m为所需的分区轮数，设<span class="math inline">\(r_i\)</span>为分区轮数 <span class="math inline">\(i\)</span> 需要读入的页面数，设<span class="math inline">\(w_i\)</span>为需要从分区轮数 <span class="math inline">\(i\)</span> 中写入的页面数；设X为分区后需要构建哈希表的页面总数。以下是I/O数量的公式：</p>
<figure>
<img src="/2022/08/10/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_6/image-20220912160639247.png" alt="image-20220912160639247"><figcaption aria-hidden="true">image-20220912160639247</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/08/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_5/" class="post-title-link" itemprop="url">数据库————排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-05 10:27:27" itemprop="dateCreated datePublished" datetime="2022-08-05T10:27:27+08:00">2022-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 19:55:25" itemprop="dateModified" datetime="2022-09-15T19:55:25+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="排序">排序</h1>
<p>在CS61B中，您了解了许多不同的排序算法。为什么我们在这节课上又学了一个新的？所有传统的排序算法（即快速排序、插入排序等）都依赖于我们能够将所有数据存储在内存中。这是我们在开发数据库时没有的奢侈。事实上，在大多数情况下，我们的数据将比我们可用的内存大一个数量级。</p>
<h2 id="io-review">1 I/O Review</h2>
<p>请记住，无论何时从内存向磁盘写入页面或从磁盘向内存读取页面，都会产生1个I/O。由于进入磁盘非常耗时，在分析算法性能时，我们只考虑算法产生的I/O数量，而不是像big-O这样的传统算法复杂性度量。因此，在开发我们的排序算法时，我们将尝试最小化它将导致的I/O数量。在计算I/O时，我们忽略缓冲区管理器进行的任何潜在缓存。这意味着，一旦我们解开页面并说我们已经使用它，下一次尝试访问页面时，它将总是花费1个I/O。</p>
<h2 id="双向外部合并排序">2.双向外部合并排序</h2>
<p>让我们从开发一个排序算法开始，该算法可以工作，但不尽可能好。因为我们不能一次将所有数据保存在内存中，所以我们知道我们将分别对数据的不同部分进行排序，然后将它们合并在一起。</p>
<p>为了有效地合并两个列表，必须首先对它们进行排序。这意味着排序算法的第一步应该是对每个页面上的记录进行排序。我们将第一阶段称为“控制”阶段，因为我们正在控制单个页面。</p>
<p>之后，让我们开始使用合并排序中的合并算法将页面合并在一起。我们将调用这些合并排序运行的结果。排序运行是一系列已排序的页面。</p>
<p>算法的其余部分将只是继续合并这些排序运行，直到只剩下一个排序运行。一次排序运行意味着我们的数据已完全排序！请参阅下一页的图像，了解算法运行到完成的图表。</p>
<figure>
<img src="/2022/08/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_5/image-20220908210736344.png" alt="image-20220908210736344"><figcaption aria-hidden="true">image-20220908210736344</figcaption>
</figure>
<h2 id="双向合并分析">3.双向合并分析</h2>
<p>在分析数据库算法时，最重要的度量是该算法使用的I/O数量，因此让我们从这里开始。首先，请注意，每次传递数据都需要2∗ N个I/O，其中N是数据页的数量。这是因为对于每一次传递，我们需要读入每一页，并在修改后写回每一页。</p>
<p>剩下要做的唯一一件事就是计算出我们需要多少次传递才能对表进行排序。我们总是需要做最初的“控制”，所以我们总是至少有一个传递。现在，需要多少次合并过程？每通过一次，我们将剩下的排序运行数量减半。每次对数据进行分割都会向您显示日志，因为我们将其除以2，所以日志的基数将为2。接着我们需要$log_2(N) <span class="math inline">\(次传递，总共\)</span>+log_2(N) $次传递。所以我们总共需要 <span class="math inline">\(2N*(1+\lceil log_2(N) \rceil)\)</span> 次I/O（注意：传递0，即初始控制通过，在外部排序中计算为一次传递，并作为I/O成本公式中的一个传递）。</p>
<p>现在，让我们分析执行该算法需要多少缓冲页。请记住，缓冲页或缓冲帧是内存中页的slot 。</p>
<p>第一次传递，即“控制传递”，对每个页面进行单独排序。这意味着我们只需要一个缓冲页来保存我们正在排序的页面！</p>
<p>现在让我们分析合并过程。回想一下合并排序中合并的工作方式。我们只比较合并的两个列表中的第一个值。这意味着我们只需要在内存中存储每个排序运行的第一页，而不是整个排序运行。当我们浏览了一个页面中的所有记录后，我们只需从内存中删除该页面，并加载到排序运行的下一个页面。到目前为止，我们需要2个缓冲页（每个排序运行1个缓冲页）。我们将调用缓冲帧，用于存储每个排序运行的输入缓冲区的前端。</p>
<p>我们现在唯一缺少的是一个存储输出的地方。我们需要在某个地方写入记录，因此我们需要另外一个页面，称为输出缓冲区。每当这个页面填满时，我们就将它刷新到磁盘并开始构建下一个页面。总的来说，我们有两个输入缓冲区和一个输出缓冲区，每个合并过程总共需要3个页面。我们通常有超过3个页面可用于内存排序，因此该算法没有利用我们所有的内存。让我们构造一个更好的算法，使用我们所有的内存。</p>
<h2 id="完全外部排序">4完全外部排序</h2>
<p>假设我们有B个缓冲区页面可用。我们将进行的第一个优化是在初始的“控制过程”中。我们不只是对单个页面进行排序，而是加载B页面并将它们一次排序到一个排序运行中。这样，我们将在第一次通过后产生更少和更长的排序运行。</p>
<p>第二个优化是一次合并两个以上的排序运行。我们有B个可用的缓冲帧，但输出缓冲区需要1。这意味着我们可以有B-1输入缓冲区，因此可以一次合并B-1排序运行。假设我们有4个可用的缓冲帧，请参阅下一页的此类图表。</p>
<figure>
<img src="/2022/08/05/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_5/image-20220908213442785.png" alt="image-20220908213442785"><figcaption aria-hidden="true">image-20220908213442785</figcaption>
</figure>
<p>现在，我们在控制阶段一次取4页，并输出长度为4的排序运行。在合并过程中，我们可以一次合并征服过程中产生的所有三个排序块。这将通过次数（因此我们的I/O）减少了一半！</p>
<h2 id="完全外部合并排序的分析">5.完全外部合并排序的分析</h2>
<p>现在，让我们计算一下改进后的排序使用与双向合并相同的进程需要多少I/O。控制传递现在只生成<span class="math inline">\(\lceil N/B \rceil\)</span>排序的运行，因此我们要合并的运行较少。在合并过程中，我们将排序的运行数除以B−1而不是2，因此日志的基础需要更改为B− 1.这使得我们的整体排序采用<span class="math inline">\(1+\lceil log_{B−1}\lceil N/B\rceil\)</span> 传递，因此总共<span class="math inline">\(2N*(1+\lceil log_{B−1}\lceil N/B\rceil)\)</span>次I/O。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/" class="post-title-link" itemprop="url">数据库————关系代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-30 10:27:27" itemprop="dateCreated datePublished" datetime="2022-07-30T10:27:27+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 20:28:39" itemprop="dateModified" datetime="2022-09-15T20:28:39+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关系代数">关系代数</h1>
<h2 id="动机">1 动机</h2>
<p>在前面的注释中，我们讨论了SQL是一种声明性编程语言。这意味着您可以指定想要什么，但不必指定如何执行。从用户的角度来看，这很好，因为它使查询更容易编写。然而，作为数据库工程师，我们通常需要一种更具表现力的语言。当我们在几周内研究查询优化时，我们将需要一种方法来表达数据库可以用来执行查询的许多不同的有效计划。为此，我们将使用关系代数，这是一种过程编程语言（这意味着查询将精确指定要使用的运算符和顺序）。</p>
<h2 id="关系代数导论">2 关系代数导论</h2>
<p>关系代数中的所有运算符都取一个关系并输出一个关系。基本查询如下所示：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908161602181.png"></p>
<p>π运算符只选择要前进到下一个运算符的列（就像SQL SELECT）。在这种情况下，运算符将dogs关系作为参数，并返回一个仅具有dogs关系的name列的关系。关于关系代数的一个重要事实是，关系是元组的集合，这意味着它们不能有重复。如果dogs关系最初为：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908161805215.png"></p>
<p>上述查询将返回：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908161823675.png"></p>
<p>最初，这两个buster是不同的，因为它们具有不同的年龄，但一旦去掉年龄列，它们就会变成重复的，因此输出关系中只保留一个。</p>
<p>让我们正式介绍关系代数运算符。</p>
<h2 id="projection-π">3 Projection (π)</h2>
<p>我们已经介绍了投影操作符，它只选择指定的列。与运算符的几乎所有参数一样，列在运算符的下标中指定。投影运算符是关系代数版本的SQL SELECT子句。</p>
<p>现在，我们可以用关系代数表示只涉及SELECT和FROM子句的SQL查询。例如SQL查询：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908162233921.png"></p>
<p>可以用我们在第2节中介绍的表达式表示：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908162307165.png"></p>
<p>请注意，在关系代数中没有与FROM运算符等效的运算符，因为这些运算符的参数指定了我们从哪些表中提取。</p>
<h2 id="selection-σ">4 Selection (σ)</h2>
<p>选择运算符用于根据特定条件筛选行。不要让名称迷惑您-这个操作符相当于SQL的WHERE子句，而不是SELECT子句。让我们尝试用关系代数来表达以下查询：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908172628762.png"></p>
<p>等价的关系代数表达式是：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908172712467.png"></p>
<p>该查询的另一个正确表达式是：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908172741185.png"></p>
<p>这说明了关系代数的美。只有一种（合理的）方法可以为查询试图完成的任务编写SQL，但我们可以在关系代数中找到多个不同的表达式，得到相同的结果。在第一个表达式中，我们首先只选择需要的列，然后过滤掉不需要的行。在第二种方法中，我们先过滤行，然后选择列。我们将很快了解评估这些计划中哪一个更好的方法！</p>
<p>选择运算符还支持复合谓词。这个∧ 符号对应于SQL中的AND关键字∨ 符号对应于OR关键字。例如</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908172852530.png"></p>
<p>等价于：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908172906373.png"></p>
<h2 id="union">5 Union (∪)</h2>
<p>我们将学习如何组合来自不同关系的数据的第一种方法是使用union运算符。就像SQL中的UNION子句一样，我们从每个元组中获取所有行，并将它们合并，同时删除重复项。例如，假设我们有一张狗表：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908173004877.png"></p>
<p>还有一张猫表，看起来像这样：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908173030584.png"></p>
<p>表达式：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908173050216.png"></p>
<p>会返回</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908173112852.png"></p>
<p>请注意，Garfield只显示一次，因为关系是元组的集合，因此会删除所有重复项。此外，请注意，所有这些集合运算符的一条规则是，它们必须对具有相同数量属性（列）的关系进行操作，并且属性必须具有相同的类型。将具有两列的关系与仅具有一列的关系合并是不合法的，将具有字符串列的关系和具有整数列的另一关系合并也是不合法的。</p>
<h2 id="set-difference--">6 Set Difference (-)</h2>
<p>另一个集运算符是集差运算符。Set difference等同于SQL子句EXCEPT。它返回第一个表中的每一行，第二个表中也显示的行除外。如果您运行：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182028895.png"></p>
<p>在上一节介绍的狗和猫表上的表达式，您将得到：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182058445.png"></p>
<p>加菲尔德没有出现，因为他在猫表中，猫的名字都不会出现，因为只有第一个关系中的行才可能出现在输出中。</p>
<h2 id="intersection">7 Intersection (∩)</h2>
<p>交集与交集SQL运算符类似，因为它只保留交集中两个表中出现的行。如果您运行：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182211969.png"></p>
<p>在第5节介绍的表格中，您将得到：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182231973.png"></p>
<p>因为Garfield是两个表中唯一出现的名称。</p>
<h2 id="cross-product">8 Cross Product (×)</h2>
<p>叉积运算符就像在SQL中执行笛卡尔积一样。输出是每个可能的元组对的一个元组，同时确保始终从最终输出中删除重复项，以满足集合语义。例如，假设我们有一张狗表：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182340017.png"></p>
<p>和一张公园表：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182414471.png"></p>
<p>关系代数等价于</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182436804.png"></p>
<p>的是</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182450247.png"></p>
<p>输出会是：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908182508253.png"></p>
<p>事实上，叉积（×）是内部连接的基础，我们将在下一步讨论。</p>
<h2 id="joinsjoin">9 Joins(<span class="math inline">\(\Join\)</span>)</h2>
<p>我们还没有讨论如何在关系代数中表示连接-让我们解决这个问题！要将两个表内部连接在一起，请在 <span class="math inline">\(\Join\)</span> 运算符的左侧编写左表，将连接条件放在下标中，并将右运算符放在右侧。要将“名称”列中的“猫”表和“狗”表连接在一起，您可以编写：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908204949556.png"></p>
<p>如果不指定连接条件，它将成为自然连接。回想一下SQL注释，自然连接将每个表中具有相同名称的所有列连接在一起。因此，您也可以编写与上述相同的查询，如下所示：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205103236.png"></p>
<p>形式上，我们将内部连接运算符称为θ连接（ <span class="math inline">\(\Join_{θ}\)</span>）。θ是连接条件，因此对于上面的表达式，θ连接条件是cats.name=dogs.name。</p>
<p>运算符执行一个内部连接，这是我们将在这个类中讨论的关系代数表达式的唯一连接。有一些方法可以从我们已经介绍的运算符派生右、左和全外部联接，但这超出了此类的范围。</p>
<p>与选择运算符σ一样，连接运算符<span class="math inline">\(\Join\)</span> 也支持复合谓词运算符∧ （及）及∨ (或)。</p>
<p>θ连接和自然连接实际上可以从叉积（×）和选择的连接（σ）导出。例如</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205452171.png"></p>
<p>可以被写做</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205505284.png"></p>
<p>自然连接</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205540489.png"></p>
<p>可以被写作</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205600970.png"></p>
<h2 id="rename-ρ">10 Rename (ρ)</h2>
<p>重命名操作符基本上完成了与SQL中的别名相同的任务。如果您希望避免像连接部分中的表达式那样，在表达式的其余部分包含表名，您可以改为编写：</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205644995.png"></p>
<p>此表达式将dogs关系的名称列重命名为dname first，因此列名中没有冲突。您不能再使用自然联接，因为列没有相同的名称，但如果您想包含其他运算符，则不再需要指定列来自哪个关系。</p>
<h2 id="group-by-aggregation-γ">11 Group By / Aggregation (γ)</h2>
<p>我们将讨论的最后一个关系代数运算符是groupby/aggregation运算符，它本质上等同于在SQL中使用groupby和HAVING子句。例如，SQL查询</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205837366.png"></p>
<p>可以在关系代数中表示为</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205855770.png"></p>
<p>此外，γ运算符可用于从SQL中选择聚合列，如MAX、MIN、SUM、COUNT等。此已修改的查询来自前面</p>
<figure>
<img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205934546.png" alt="image-20220908205934546"><figcaption aria-hidden="true">image-20220908205934546</figcaption>
</figure>
<p>可以在关系代数中表示为</p>
<p><img src="/2022/07/30/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_4/image-20220908205953524.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/" class="post-title-link" itemprop="url">数据库————缓冲区管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-25 10:27:27" itemprop="dateCreated datePublished" datetime="2022-07-25T10:27:27+08:00">2022-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 20:24:09" itemprop="dateModified" datetime="2022-09-15T20:24:09+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="缓冲区管理">缓冲区管理</h1>
<h2 id="简介">1 简介</h2>
<p>到目前为止，我们已经讨论了如何在数据库管理系统的最低级别管理磁盘空间，以及如何在基于页面的数据库系统中管理文件和索引。我们现在将探讨DBMS上这两个级别之间的接口-缓冲区管理器。</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220907221359329.png"></p>
<p>缓冲区管理器负责管理内存中的页面，并处理来自文件和索引管理器的页面请求。请记住，内存空间是有限的，因此我们无法在缓冲池中存储所有页面。缓冲区管理器负责收回策略，或者在空间已满时选择要收回的页面。当从内存中逐出页面或将新页面读入内存时，缓冲区管理器与磁盘空间管理器通信以执行所需的磁盘操作。</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220907221459150.png"></p>
<h2 id="缓冲池">2 缓冲池</h2>
<p>通过将空间划分为可放置页面的帧，将内存转换为缓冲池。缓冲帧可以保存与页面相同数量的数据（因此页面完全适合于帧）。为了有效地跟踪帧，缓冲区管理器为元数据表分配额外的内存空间。</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220907221655999.png"></p>
<p>该表跟踪4条信息：</p>
<p>1.与存储器地址唯一关联的帧ID</p>
<p>2.用于确定帧当前包含的页面的页面ID</p>
<p>3.用于验证页面是否已修改的脏位</p>
<p>4.用于跟踪当前使用页面的请求者数量的Pin计数</p>
<h2 id="处理页面请求">3 处理页面请求</h2>
<p>当从缓冲区管理器请求页面并且页面已经存在于内存中时，页面的pin计数将递增，并返回页面的内存地址。</p>
<p>如果缓冲池中不存在页，并且仍有空间，则会找到下一个空帧，并将页读入该帧。页面的pin计数设置为1，并返回页面的内存地址。如果页面不存在并且没有剩余的空帧，则必须使用替换策略来确定要退出的页面。</p>
<p>替换策略的选择在很大程度上取决于页面访问模式，通过计算页面访问次数来选择最佳策略。页面命中是指可以在内存中找到请求的页面，而无需转到磁盘。每个页面丢失都会导致额外的IO成本，因此良好的逐出策略对性能至关重要。访问模式的命中率被定义为页面点击数#/（#of页面点击数+#页面未命中数），或者更简单地，页面点击数/页面访问数。</p>
<p>此外，如果被逐出的页面设置了脏位，则将页面写入磁盘，以确保保持更新。当在内存中更新页面时，脏位设置为1。页面写回磁盘后，脏位设置为0。</p>
<p>一旦请求者完成其工作负载，它负责通知缓冲区管理器减少与先前使用的页面相关联的pin数。</p>
<h2 id="lru-置换">4 LRU 置换</h2>
<p>常用的替换策略是LRU（最近最少使用）。当需要将新页读入满缓冲池时，将逐出最近使用最少的未固定页（pin计数=0）。为了跟踪页面使用情况，将向元数据表中添加“上次使用”列，并测量页面的pin计数减少的最新时间。</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220908152212168.png"></p>
<p>通常情况下，实现LRU可能成本高昂。时钟策略提供了一种替代实现，其使用元数据表中的ref位（最近引用的）列和时钟指针变量来有效地近似LRU，以跟踪所考虑的当前帧。</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220908152321653.png"></p>
<p>时钟策略算法将元数据表视为帧的循环列表。它在开始时将时钟指针设置为第一个未固定帧，并在初始读取到帧中时将每个页面对应行上的ref位设置为1。在尝试驱逐时，策略的工作方式如下：</p>
<ul>
<li>遍历表中的帧，跳过固定页并在到达末尾时环绕到帧0，直到找到ref位为0的第一个未固定帧</li>
<li>在每次迭代期间，如果当前帧的ref位=1，则将ref位设置为0，并将时钟指针移动到下一帧。</li>
<li>到达ref位为0的帧时，退出现有页（如果设置了脏位，则将其写入磁盘；然后将脏位设置为0），读取新页，将帧的ref位设置为1，并将时钟指针移动到下一帧。</li>
</ul>
<p>如果访问缓冲池中当前的页面，时钟策略将页面的ref位设置为1，而不移动时钟指针。</p>
<h3 id="顺序扫描性能-lru">4.1 顺序扫描性能-LRU</h3>
<p>LRU总体性能良好，但当一组页S（其中|S|&gt;缓冲池大小）被多次重复访问时，性能会受到影响。</p>
<p>为了强调这一点，考虑使用LRU的3帧缓冲池，并具有以下访问模式：</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220908154024096.png"></p>
<h2 id="mru更换">5 MRU更换</h2>
<p>另一个常用的替换策略是MRU（最近使用）。不是逐出最近使用的未固定页面，而是逐出最近一次使用的未锁定页面，该页面的pin计数是在最后一次减少时测量的。</p>
<h3 id="顺序扫描性能-mru">5.1 顺序扫描性能-MRU</h3>
<p>起初，使用此策略似乎有违直觉，但考虑使用MRU的3帧缓冲池具有以下访问模式的场景：</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220908154546209.png"></p>
<p>显然，无论何时出现顺序洪泛访问模式，MRU在页面命中率方面都远远优于LRU。</p>
<p><img src="/2022/07/25/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_3/image-20220915202401656.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://101.35.161.126/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wys的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/" class="post-title-link" itemprop="url">数据库————B+树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-20 10:27:27" itemprop="dateCreated datePublished" datetime="2022-07-20T10:27:27+08:00">2022-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-15 20:22:09" itemprop="dateModified" datetime="2022-09-15T20:22:09+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="b-树">B+ 树</h1>
<h2 id="简介">1 简介</h2>
<p>在前面的笔记中，我们讨论了数据存储的不同文件和记录表示。本周，我们将介绍索引，它是一种在数据文件之上运行的数据结构，有助于加快对特定键的读取。您可以将数据文件视为书籍的实际内容，将索引视为快速查找的内容表。我们使用索引使查询运行得更快，尤其是那些频繁运行的查询。考虑一个web应用程序，它在登录过程中根据用户名在用户表中查找用户的记录。用户名列上的索引将通过快速查找试图登录的用户的行来加快登录速度。在本课程注释中，我们将学习B+树，这是一种特定类型的索引。下面是一个B+树的示例：</p>
<figure>
<img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907182641290.png" alt="image-20220907182641290"><figcaption aria-hidden="true">image-20220907182641290</figcaption>
</figure>
<h2 id="属性">2 属性</h2>
<ul>
<li>d是B+树的阶，每个节点（根节点除外）必须有 <span class="math inline">\(d \leq x \leq 2d\)</span> 项，如果没有删除发生的话（删除数据后叶子节点可能少于d项）。节点中的项必须排序。</li>
<li>在内节点的两项之间有一个指针指向孩子节点，因为最多有2d项在节点中，内节点最多有2d+1个指针指向孩子节点。这也被称为树的扇出。</li>
<li>条目左侧子结点中的键必须小于条目，而右侧子节点中键必须大于或等于条目。</li>
<li>•所有叶片深度相同，且具有d和2d个条目（即至少半满）</li>
</ul>
<p>举个例子，一个阶为2的树：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907184154927.png"></p>
<p>请注意，节点满足阶要求（d≤ x≤ 2d），因为d=2并且该节点具有3个条目满足2≤ x≤ 4.</p>
<ul>
<li>由于sorted和children属性，我们可以遍历树到叶子，以找到所需的记录。这类似于BST（二进制搜索树）。</li>
<li>每个根到叶路径都有相同数量的边-这是树的高度。从这个意义上说，B+树总是平衡的。换句话说，只有根节点的B+树的高度为0。</li>
<li>只有叶节点包含记录（或指向记录的指针-这将在后面解释）。内部节点（即非叶节点）不包含实际记录。</li>
</ul>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907184919816.png"></p>
<h2 id="插入">3 插入</h2>
<p>要在B+树中插入条目，请执行以下步骤：</p>
<p>（1） 找到要插入值的叶节点L。您可以通过遍历树来实现这一点。按顺序将键和记录添加到叶节点。</p>
<p>（2） 如果L溢出（L超过2d项）</p>
<p>​ （a）分成<span class="math inline">\(L_1\)</span>,<span class="math inline">\(L_2\)</span>。 <span class="math inline">\(L_1\)</span>中保持d个条目，这意味<span class="math inline">\(L_2\)</span>中为d+1。</p>
<p>​ （b） 如果L是叶节点，则将<span class="math inline">\(L_2\)</span>的第一个条目复制到父节点中。如果L不是叶节点，则将<span class="math inline">\(L_2\)</span>的第一个条目移动到父节点中。</p>
<p>​ （c） 调整指针。</p>
<ol start="3" type="1">
<li>如果父节点溢出，则通过对父节点执行步骤2来递归。（这是增加树高的唯一情况。）</li>
</ol>
<p>注意：我们希望将叶节点数据复制到父节点中，以便不丢失叶节点中的数据。请记住，建立索引的表中的每个键都必须位于叶节点中！处于内部节点并不意味着键实际上仍在表中。另一方面，我们可以将内部节点数据移动到父节点中，因为内部节点不包含实际数据，它们只是遍历树时搜索方法的参考。</p>
<p>让我们看一个例子来更好地理解这个过程！我们从以下顺序d=1树开始：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907190309483.png"></p>
<p>插入19。当插入19，我们可以看到17旁边有个空位。</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907190334781.png"></p>
<p>接着我们插入21。当我们插入21， 这会造成叶子节点溢出。而且，我们把叶子节点拆成如下所示：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907190542981.png"></p>
<p>因为我们拆分了叶子节点我们把 <span class="math inline">\(L_2\)</span> 的第一个节点复制到父节点，然后调整指针，然后对父节点排序得到：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907190836774.png"></p>
<p>让我们再做一次插入。这次我们将插入36。当我们插入36时，叶溢出，因此我们将执行与插入21时相同的过程以获得：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907190929710.png"></p>
<p>注意，现在父节点溢出，所以现在必须递归。我们将拆分父节点以获得：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907191011137.png"></p>
<p>由于是一个内部节点溢出，我们将L2的第一个条目上移到父节点，并调整指针以获得：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907191101647.png"></p>
<p>最后，这里有几个关于插入B+树的说明：</p>
<ul>
<li><p>通常，B+树节点具有最小的d个条目和最大的2d个条目。在其他换句话说，如果树中的节点在插入之前满足此不变量（通常）则在插入之后，它们将继续满足它。</p></li>
<li><p>当节点包含超过2d个条目时，会发生节点插入溢出。</p></li>
</ul>
<h2 id="删除">4 删除</h2>
<p>要删除一个值，只需找到适当的叶并从该叶中删除不需要的值。这就是它的全部内容。（是的，从技术上讲，我们最终可能会违反B+树的一些不变量。这没关系，因为在实践中，我们得到的插入比删除多得多，所以我们删除的东西会很快被替换。）</p>
<p>提醒：我们从不删除内部节点键，因为它们仅用于搜索，而不用于保存数据。</p>
<h2 id="存储记录">5 存储记录</h2>
<p>到目前为止，我们还没有讨论记录实际上是如何存储在叶子中的。现在让我们来看看。有三种方式将记录存储在叶子中：</p>
<ul>
<li>备选方案1</li>
</ul>
<p>​ 在备选方案1中，叶页是数据页。叶页不包含指向记录的指针，而是包含记录本身。</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907193844805.png"></p>
<ul>
<li>备选方案2</li>
</ul>
<p>​ 在备选方案2中，叶页保存指向相应记录的指针。</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907193910737.png"></p>
<ul>
<li><p>备选方案3</p>
<p>在备选方案3中，叶页保存指向相应记录的指针列表。当有多个记录具有相同的叶节点条目时，这比备选方案2更紧凑。</p></li>
</ul>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907194032912.png"></p>
<h2 id="聚类">6 聚类</h2>
<p>既然我们已经讨论了如何在叶节点中存储记录，我们还将讨论如何组织数据页上的数据。集群/非集群是指数据页的结构。由于叶页是备选1的实际数据页，并且键在索引叶页上排序，因此默认情况下，备选1索引是聚集的。因此，取消群集仅适用于备选方案2或3。</p>
<ul>
<li>未群集</li>
</ul>
<p>​ 在未群集索引中，数据页完全混乱。因此，很可能您需要为每个记录读取单独的页面。例如，考虑以下示例：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907195742633.png"></p>
<p>在上图中，如果我们想读取12和24的记录，那么我们必须读取它们指向的每个数据页，以便检索与这些键关联的所有记录。</p>
<ul>
<li>群集</li>
</ul>
<p>在聚集索引中，数据页在构建B+树的同一索引上排序。这并不意味着数据页被精确排序，只是键的顺序与数据大致相同。因此，I/O成本的差异来自缓存，其中两个具有关闭键的记录可能位于同一页中，因此可以从缓存页读取第二个记录。因此，您通常只需要读取一个页面，就可以获得具有公共/类似密钥的所有记录。例如，考虑以下示例：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907200112516.png"></p>
<ul>
<li><p>未群集=∼ 每个记录1个I/O。</p></li>
<li><p>群集=∼ 每页记录1个I/O。</p></li>
<li><p>聚集索引与非聚集索引</p></li>
</ul>
<p>虽然聚集索引可以更有效地进行范围搜索，并在顺序磁盘访问和预取等过程中提供潜在的局部性优势，但它们通常比非聚集索引维护成本更高。例如，随着更多插入的到来，数据文件可能变得不那么集群化，因此需要定期对文件进行排序。</p>
<h2 id="io计数">7 IO计数</h2>
<p>这是一般程序。在备忘单上写下以下内容是一件好事：</p>
<p>（1） 读取相应的根到叶路径。</p>
<p>（2） 读取相应的数据页。如果需要读取多个页面，我们将分配一个读取IO</p>
<p>对于每个页面。此外，我们考虑了备选方案2或3的聚类（见下文）</p>
<p>（3） 如果要修改，请写入数据页。同样，如果我们要进行跨越多个</p>
<p>对于数据页，我们需要为每个页分配一个写IO。</p>
<p>（4） 更新索引页。</p>
<p>让我们看一个例子。参见以下备选方案2未群集的B+树：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907200622457.png"></p>
<p>我们想从数据库中删除只有11岁的孩子。需要多少I/O？</p>
<ul>
<li><p>2个相关索引页（索引页是内部节点或叶节点）的每一个都有一个I/O。</p></li>
<li><p>一个I/O，用于读取11岁儿童记录所在的数据页。一旦记录在内存中，我们可以从页面中删除记录。</p></li>
<li><p>一个I/O，将修改后的数据页写回磁盘。</p></li>
<li><p>既然我们的数据库中不再有11岁的孩子，我们应该从B+树的叶页中删除键“11”，我们已经在步骤1中读取了该键。我们这样做，然后需要一个I/O将修改后的叶页写入磁盘。</p></li>
<li><p>因此，删除记录的总成本为5 I/O。</p></li>
</ul>
<h2 id="散货装载">8 散货装载</h2>
<p>我们之前讨论的插入过程对于对现有B+树进行添加非常有用。但是，如果我们想从头开始构建B+树，我们可以做得更好。这是因为如果我们使用插入过程，每次我们想要插入新的东西时，我们都必须遍历树；定期插入随机数据页也会导致缓存效率低下和叶页利用率低下，因为它们通常是半空的。相反，我们将使用批量装载：</p>
<p>（1） 按索引将基于的键对数据进行排序。</p>
<p>（2） 填充叶页直到某个填充因子f。请注意，填充因子仅适用于叶节点。对于内部节点，我们仍然遵循相同的规则进行插入，直到它们满为止。</p>
<p>（3） 添加从父页面到叶页面的指针。如果父级溢出，我们将遵循类似于插入的过程。我们将父节点拆分为两个节点：</p>
<p>​ （a） 在L1中保留d个条目（这意味着d+1个条目将进入L2）。</p>
<p>​ （b） 由于父节点溢出，我们将L2的第一个条目移动到父节点中。</p>
<p>（4） 调整指针。</p>
<p>让我们看一个例子。假设我们的填充因子是3/4，我们想将1，…，20插入到一个d=2阶树中。我们将从填充页开始，直到填充因子：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907201300664.png"></p>
<p>我们已将叶节点填充到填充因子3/4，并添加了从父节点到叶节点的指针。让我们继续填写：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907201432462.png"></p>
<p>在上图中，我们看到父节点已溢出。我们将父节点拆分为两个节点，并创建一个新的父节点：</p>
<p><img src="/2022/07/20/cs186%E6%95%B0%E6%8D%AE%E5%BA%93/CS186_2/image-20220907201553616.png"></p>
<p>从上面的示例中可以看出，从批量加载构建的索引总是以集群开始，因为基础数据是按键排序的。为了保持聚类，我们可以根据未来的插入模式选择填充因子</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
